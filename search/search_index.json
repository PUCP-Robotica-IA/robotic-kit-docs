{"config":{"indexing":"full","lang":["es"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Firmware educativo para Kits Rob\u00f3ticos \u2013 PUCP Este repositorio contiene el firmware base desarrollado en MicroPython para kits rob\u00f3ticos educativos utilizados en la carrera de Ingenier\u00eda Mecatr\u00f3nica en la Pontificia Universidad cat\u00f3lica del Per\u00fa . El proyecto est\u00e1 dise\u00f1ado para facilitar el aprendizaje pr\u00e1ctico de temas fundamentales en rob\u00f3tica m\u00f3vil y rob\u00f3tica de manipuladores. Objetivos del proyecto Desarrollar una plataforma de firmware modular y educativa que permita a los estudiantes: Objetivos Comprender y experimentar con cinem\u00e1tica de robots m\u00f3viles (diferencial, ackermann, mecanum). Programar y controlar brazos rob\u00f3ticos. Implementar algoritmos como \"Go to Goal\", planificaci\u00f3n de trayectorias y filtros de Kalman. Utilizar sensores reales (IMU, encoders, sensores ultras\u00f3nicos). Familiarizarse con conceptos de navegaci\u00f3n, control y percepci\u00f3n. Plataformas soportadas Robot con ruedas mecanum Brazos rob\u00f3ticos (Futuro) Vehiculo diferencial, ackerman, Robots con patas, LIDAR, otros sensores Estructura del repositorio Software_Pico/ \u2502 \u251c\u2500\u2500 firmware/ \u2190 C\u00f3digo fuente principal del firmware \u2502 \u251c\u2500\u2500 config/ \u2190 Archivos de configuraci\u00f3n (hardware, estudiantes) \u2502 \u251c\u2500\u2500 robot/ \u2190 Implementaciones de los distintos robots \u2502 \u251c\u2500\u2500 sensors/ \u2190 Interfaces para sensores (IMU, encoder, ultras\u00f3nicos) \u2502 \u251c\u2500\u2500 utils/ \u2190 Utilidades compartidas (PID, secuencias, jacobianos) \u2502 \u2514\u2500\u2500 libraries/ \u2190 Librer\u00edas externas o wrappers (MQTT, IMU) \u2502 \u251c\u2500\u2500 student_examples/ \u2190 Ejemplos de c\u00f3digo para uso en laboratorios \u251c\u2500\u2500 labs/ \u2190 Pr\u00e1cticas guiadas por tema o curso \u251c\u2500\u2500 tests/ \u2190 Scripts internos para pruebas de hardware/software \u2502 \u2514\u2500\u2500 helpers/ \u2190 Utilidades para pruebas \u251c\u2500\u2500 docs/ \u2190 Documentaci\u00f3n t\u00e9cnica y gu\u00edas de uso \u2502 \u2514\u2500\u2500 hardware \u2190 Diagramas de conexiones y specificaciones \u2502 \u2514\u2500\u2500 modules \u2190 Documentacion de modulos para uso de estudiantes \u2514\u2500\u2500 dev_tools/ \u2190 Scripts para compilaci\u00f3n, flasheo, etc. Gu\u00eda de Inicio para Estudiantes Sigue estos pasos en orden para configurar tu robot desde cero y dejarlo listo para los laboratorios. Parte 1: Preparaci\u00f3n del Entorno En esta parte, instalar\u00e1s todo el software necesario en tu computadora y en la placa Pico W. Paso 1: Instalar el Firmware en la Pico W Sigue las instrucciones de la Gu\u00eda 1: Instalaci\u00f3n del Firmware para preparar tu placa. Paso 2: Ejecutar tu Primer Programa Aprende a usar Thonny con la Gu\u00eda 2: Tu primer programa con Thonny . Paso 3: Cargar los Archivos del Robot Transfiere las librer\u00edas a tu placa siguiendo la Gu\u00eda 3: Carga de archivos base . Parte 2: Configuraci\u00f3n y Verificaci\u00f3n del Robot Una vez finalizada la configuraci\u00f3n del entorno, el siguiente paso es la calibraci\u00f3n de los motores para asegurar su correcto funcionamiento. Paso 4: Verificaci\u00f3n y Ajuste de la Direcci\u00f3n de los Motores Se debe seguir un proceso iterativo de prueba y ajuste para cada motor del robot. Abrir el script de diagn\u00f3stico: Mediante Thonny, abra el archivo 1_test_wheel_direction.py , ubicado en el directorio student_examples/ de su proyecto local. Seleccionar el motor a probar: En el c\u00f3digo fuente del script, modifique el valor del par\u00e1metro motor_id en la llamada a la funci\u00f3n test_wheel_direction() . Asigne el \u00edndice del motor que desea verificar (p. ej., motor_id=0 para el primer motor). # En el archivo 1_test_wheel_direction.py ROBOT_TYPE = 'test' # Inicializa la instancia del robot con los par\u00e1metros correspondientes robot = get_robot ( ROBOT_TYPE , CONFIG [ ROBOT_TYPE ]) # Ejecuta la prueba en el motor con \u00edndice 1 # Realizar la prueba con cada motor y modificar la configuraci\u00f3n # en config.py seg\u00fan corresponda test_wheel_direction ( robot , motor_id = 1 ) Ejecutar la prueba: Ejecute el script en Thonny (\u25b6). Observe el comportamiento f\u00edsico de la rueda seleccionada y la informaci\u00f3n de diagn\u00f3stico que se imprime en la consola. Aplicar correcciones (si es necesario): Si el comportamiento observado no es el esperado, abra el archivo de configuraci\u00f3n /config/student_config.py ubicado en la memoria de la Raspberry Pi Pico. Advertencia Importante No modifiques config.mpy \u2014 este archivo est\u00e1 protegido y contiene la configuraci\u00f3n base. Modifica \u00fanicamente student_config.py . Aplique los siguientes ajustes seg\u00fan el caso: * Rotaci\u00f3n del motor invertida: Si el motor gira en la direcci\u00f3n opuesta a la esperada, a\u00f1ada el par\u00e1metro \"inverted\": True al diccionario del motor correspondiente. * Lectura del encoder invertida: Si la consola indica que la lectura del encoder es incorrecta, a\u00f1ada el par\u00e1metro \"encoder_inverted\": True . * Operaci\u00f3n correcta: Si el motor funciona correctamente, el diccionario correspondiente debe permanecer vac\u00edo ( {} ). # Ejemplo de aplicaci\u00f3n de correcciones en /config/student_config.py MOTOR_DIRECTION = [ { \"inverted\" : True }, # Motor 0: requer\u00eda inversi\u00f3n de giro. {}, # Motor 1: operaba correctamente. { \"encoder_inverted\" : True }, # Motor 2: requer\u00eda inversi\u00f3n de la lectura del encoder. # ... y as\u00ed sucesivamente. ] Guardar y repetir el proceso: Guarde los cambios en el archivo student_config.py y repita los pasos 2 a 4 para cada uno de los motores del robot. Documentaci\u00f3n Detallada Para una explicaci\u00f3n exhaustiva de los par\u00e1metros de configuraci\u00f3n, incluyendo diagramas y ejemplos visuales de cada caso de prueba, consulte la siguiente gu\u00eda: \u27a1\ufe0f Gu\u00eda de Configuraci\u00f3n y Calibraci\u00f3n de Motores Laboratorios incluidos Carpeta Tema labs/pid_speed Control PID de velocidad labs/go_to_goal Movimiento hacia un objetivo (Go-to-Goal) labs/trajectory Planificaci\u00f3n de trayectorias labs/kalman Estimaci\u00f3n de estado con Filtro de Kalman labs/manipulators Cinem\u00e1tica de manipuladores Versionado Cada semestre acad\u00e9mico se etiqueta una versi\u00f3n estable del repositorio. Ejemplos de etiquetas ( tags ) Las versiones estables siguen el formato v<a\u00f1o>-<semestre>-labkit . v2025-1-labkit \u2192 Semestre 2025-1 v2024-2-labkit \u2192 Semestre 2024-2 Para ver y utilizar una versi\u00f3n anterior, puedes usar los siguientes comandos: git tag git checkout v2024-2-labkit Listar versiones: El comando git tag te mostrar\u00e1 todas las etiquetas disponibles en el historial del proyecto. Cambiar de versi\u00f3n: Una vez que identifiques la etiqueta que necesitas, git checkout te permite \"viajar en el tiempo\" a ese punto exacto del c\u00f3digo. Organizaci\u00f3n del Desarrollo Las contribuciones del equipo se organizan a trav\u00e9s de las siguientes ramas principales: Flujo de Ramas en Git main \u2014 Versi\u00f3n estable. dev \u2014 Desarrollo activo. feature/<nombre> \u2014 Funcionalidades nuevas en desarrollo. course/<curso> \u2014 Adaptaciones espec\u00edficas para cursos o pr\u00e1cticas Licencia Este proyecto es de uso acad\u00e9mico exclusivo para cursos dictados en la PUCP. Para solicitudes de uso externo, contactar con el equipo docente o coordinador del proyecto. Contacto Para dudas, soporte o sugerencias: Coordinador t\u00e9cnico: [dequiroz@pucp.edu.pe] Repositorio oficial: https://github.com/PUCP-Robotica-IA/robotic-kit-docs","title":"Introducci\u00f3n"},{"location":"#firmware-educativo-para-kits-roboticos-pucp","text":"Este repositorio contiene el firmware base desarrollado en MicroPython para kits rob\u00f3ticos educativos utilizados en la carrera de Ingenier\u00eda Mecatr\u00f3nica en la Pontificia Universidad cat\u00f3lica del Per\u00fa . El proyecto est\u00e1 dise\u00f1ado para facilitar el aprendizaje pr\u00e1ctico de temas fundamentales en rob\u00f3tica m\u00f3vil y rob\u00f3tica de manipuladores.","title":"Firmware educativo para Kits Rob\u00f3ticos \u2013 PUCP"},{"location":"#objetivos-del-proyecto","text":"Desarrollar una plataforma de firmware modular y educativa que permita a los estudiantes: Objetivos Comprender y experimentar con cinem\u00e1tica de robots m\u00f3viles (diferencial, ackermann, mecanum). Programar y controlar brazos rob\u00f3ticos. Implementar algoritmos como \"Go to Goal\", planificaci\u00f3n de trayectorias y filtros de Kalman. Utilizar sensores reales (IMU, encoders, sensores ultras\u00f3nicos). Familiarizarse con conceptos de navegaci\u00f3n, control y percepci\u00f3n.","title":"Objetivos del proyecto"},{"location":"#plataformas-soportadas","text":"Robot con ruedas mecanum Brazos rob\u00f3ticos (Futuro) Vehiculo diferencial, ackerman, Robots con patas, LIDAR, otros sensores","title":"Plataformas soportadas"},{"location":"#estructura-del-repositorio","text":"Software_Pico/ \u2502 \u251c\u2500\u2500 firmware/ \u2190 C\u00f3digo fuente principal del firmware \u2502 \u251c\u2500\u2500 config/ \u2190 Archivos de configuraci\u00f3n (hardware, estudiantes) \u2502 \u251c\u2500\u2500 robot/ \u2190 Implementaciones de los distintos robots \u2502 \u251c\u2500\u2500 sensors/ \u2190 Interfaces para sensores (IMU, encoder, ultras\u00f3nicos) \u2502 \u251c\u2500\u2500 utils/ \u2190 Utilidades compartidas (PID, secuencias, jacobianos) \u2502 \u2514\u2500\u2500 libraries/ \u2190 Librer\u00edas externas o wrappers (MQTT, IMU) \u2502 \u251c\u2500\u2500 student_examples/ \u2190 Ejemplos de c\u00f3digo para uso en laboratorios \u251c\u2500\u2500 labs/ \u2190 Pr\u00e1cticas guiadas por tema o curso \u251c\u2500\u2500 tests/ \u2190 Scripts internos para pruebas de hardware/software \u2502 \u2514\u2500\u2500 helpers/ \u2190 Utilidades para pruebas \u251c\u2500\u2500 docs/ \u2190 Documentaci\u00f3n t\u00e9cnica y gu\u00edas de uso \u2502 \u2514\u2500\u2500 hardware \u2190 Diagramas de conexiones y specificaciones \u2502 \u2514\u2500\u2500 modules \u2190 Documentacion de modulos para uso de estudiantes \u2514\u2500\u2500 dev_tools/ \u2190 Scripts para compilaci\u00f3n, flasheo, etc.","title":"Estructura del repositorio"},{"location":"#guia-de-inicio-para-estudiantes","text":"Sigue estos pasos en orden para configurar tu robot desde cero y dejarlo listo para los laboratorios.","title":"Gu\u00eda de Inicio para Estudiantes"},{"location":"#parte-1-preparacion-del-entorno","text":"En esta parte, instalar\u00e1s todo el software necesario en tu computadora y en la placa Pico W. Paso 1: Instalar el Firmware en la Pico W Sigue las instrucciones de la Gu\u00eda 1: Instalaci\u00f3n del Firmware para preparar tu placa. Paso 2: Ejecutar tu Primer Programa Aprende a usar Thonny con la Gu\u00eda 2: Tu primer programa con Thonny . Paso 3: Cargar los Archivos del Robot Transfiere las librer\u00edas a tu placa siguiendo la Gu\u00eda 3: Carga de archivos base .","title":"Parte 1: Preparaci\u00f3n del Entorno"},{"location":"#parte-2-configuracion-y-verificacion-del-robot","text":"Una vez finalizada la configuraci\u00f3n del entorno, el siguiente paso es la calibraci\u00f3n de los motores para asegurar su correcto funcionamiento. Paso 4: Verificaci\u00f3n y Ajuste de la Direcci\u00f3n de los Motores Se debe seguir un proceso iterativo de prueba y ajuste para cada motor del robot. Abrir el script de diagn\u00f3stico: Mediante Thonny, abra el archivo 1_test_wheel_direction.py , ubicado en el directorio student_examples/ de su proyecto local. Seleccionar el motor a probar: En el c\u00f3digo fuente del script, modifique el valor del par\u00e1metro motor_id en la llamada a la funci\u00f3n test_wheel_direction() . Asigne el \u00edndice del motor que desea verificar (p. ej., motor_id=0 para el primer motor). # En el archivo 1_test_wheel_direction.py ROBOT_TYPE = 'test' # Inicializa la instancia del robot con los par\u00e1metros correspondientes robot = get_robot ( ROBOT_TYPE , CONFIG [ ROBOT_TYPE ]) # Ejecuta la prueba en el motor con \u00edndice 1 # Realizar la prueba con cada motor y modificar la configuraci\u00f3n # en config.py seg\u00fan corresponda test_wheel_direction ( robot , motor_id = 1 ) Ejecutar la prueba: Ejecute el script en Thonny (\u25b6). Observe el comportamiento f\u00edsico de la rueda seleccionada y la informaci\u00f3n de diagn\u00f3stico que se imprime en la consola. Aplicar correcciones (si es necesario): Si el comportamiento observado no es el esperado, abra el archivo de configuraci\u00f3n /config/student_config.py ubicado en la memoria de la Raspberry Pi Pico. Advertencia Importante No modifiques config.mpy \u2014 este archivo est\u00e1 protegido y contiene la configuraci\u00f3n base. Modifica \u00fanicamente student_config.py . Aplique los siguientes ajustes seg\u00fan el caso: * Rotaci\u00f3n del motor invertida: Si el motor gira en la direcci\u00f3n opuesta a la esperada, a\u00f1ada el par\u00e1metro \"inverted\": True al diccionario del motor correspondiente. * Lectura del encoder invertida: Si la consola indica que la lectura del encoder es incorrecta, a\u00f1ada el par\u00e1metro \"encoder_inverted\": True . * Operaci\u00f3n correcta: Si el motor funciona correctamente, el diccionario correspondiente debe permanecer vac\u00edo ( {} ). # Ejemplo de aplicaci\u00f3n de correcciones en /config/student_config.py MOTOR_DIRECTION = [ { \"inverted\" : True }, # Motor 0: requer\u00eda inversi\u00f3n de giro. {}, # Motor 1: operaba correctamente. { \"encoder_inverted\" : True }, # Motor 2: requer\u00eda inversi\u00f3n de la lectura del encoder. # ... y as\u00ed sucesivamente. ] Guardar y repetir el proceso: Guarde los cambios en el archivo student_config.py y repita los pasos 2 a 4 para cada uno de los motores del robot. Documentaci\u00f3n Detallada Para una explicaci\u00f3n exhaustiva de los par\u00e1metros de configuraci\u00f3n, incluyendo diagramas y ejemplos visuales de cada caso de prueba, consulte la siguiente gu\u00eda: \u27a1\ufe0f Gu\u00eda de Configuraci\u00f3n y Calibraci\u00f3n de Motores","title":"Parte 2: Configuraci\u00f3n y Verificaci\u00f3n del Robot"},{"location":"#laboratorios-incluidos","text":"Carpeta Tema labs/pid_speed Control PID de velocidad labs/go_to_goal Movimiento hacia un objetivo (Go-to-Goal) labs/trajectory Planificaci\u00f3n de trayectorias labs/kalman Estimaci\u00f3n de estado con Filtro de Kalman labs/manipulators Cinem\u00e1tica de manipuladores","title":"Laboratorios incluidos"},{"location":"#versionado","text":"Cada semestre acad\u00e9mico se etiqueta una versi\u00f3n estable del repositorio. Ejemplos de etiquetas ( tags ) Las versiones estables siguen el formato v<a\u00f1o>-<semestre>-labkit . v2025-1-labkit \u2192 Semestre 2025-1 v2024-2-labkit \u2192 Semestre 2024-2 Para ver y utilizar una versi\u00f3n anterior, puedes usar los siguientes comandos: git tag git checkout v2024-2-labkit Listar versiones: El comando git tag te mostrar\u00e1 todas las etiquetas disponibles en el historial del proyecto. Cambiar de versi\u00f3n: Una vez que identifiques la etiqueta que necesitas, git checkout te permite \"viajar en el tiempo\" a ese punto exacto del c\u00f3digo.","title":"Versionado"},{"location":"#organizacion-del-desarrollo","text":"Las contribuciones del equipo se organizan a trav\u00e9s de las siguientes ramas principales: Flujo de Ramas en Git main \u2014 Versi\u00f3n estable. dev \u2014 Desarrollo activo. feature/<nombre> \u2014 Funcionalidades nuevas en desarrollo. course/<curso> \u2014 Adaptaciones espec\u00edficas para cursos o pr\u00e1cticas","title":"Organizaci\u00f3n del Desarrollo"},{"location":"#licencia","text":"Este proyecto es de uso acad\u00e9mico exclusivo para cursos dictados en la PUCP. Para solicitudes de uso externo, contactar con el equipo docente o coordinador del proyecto.","title":"Licencia"},{"location":"#contacto","text":"Para dudas, soporte o sugerencias: Coordinador t\u00e9cnico: [dequiroz@pucp.edu.pe] Repositorio oficial: https://github.com/PUCP-Robotica-IA/robotic-kit-docs","title":"Contacto"},{"location":"configure/configure/","text":"CONFIGURACIONES INICIALES Librer\u00eda CONFIG La librer\u00eda CONFIG contiene la configuraci\u00f3n de hardware para diferentes tipos de robots. Cada tipo tiene su propia estructura, que detalla los motores, sensores y perif\u00e9ricos necesarios para operar correctamente. \ud83d\udce6 Diccionario de configuraci\u00f3n CONFIG: Diccionario centralizado El diccionario CONFIG se utiliza para definir y seleccionar configuraciones predeterminadas de hardware. Las claves representan diferentes perfiles de robot. Puedes acceder a una configuraci\u00f3n espec\u00edfica as\u00ed: from config import CONFIG ROBOT_TYPE = \"mecanum\" config_actual = CONFIG [ ROBOT_TYPE ] \ud83e\udde9 Configuraciones disponibles CONFIG[\\\"mecanum\\\"] \u2013 Robot omnidireccional completo Configura un robot con 4 ruedas mecanum y sensores integrados. Control individual de 4 motores con PWM, direcci\u00f3n y encoders. 3 sensores ultras\u00f3nicos conectados a entradas anal\u00f3gicas (ADC). Sensor IMU conectado por I2C. Imagen: Robot mecanum con 4 ruedas omnidireccionales. CONFIG[\\\"arm\\\"] \u2013 Brazo rob\u00f3tico (4DOF) Configura un brazo rob\u00f3tico de 4 grados de libertad. 4 servomotores para articulaciones. Salida de control para efector final. Sensor ultras\u00f3nico para percepci\u00f3n frontal. Imagen: Brazo rob\u00f3tico de 4DOF. CONFIG[\\\"sensors\\\"] \u2013 Sensores independientes Configuraci\u00f3n para usar solo los sensores del sistema. 3 sensores ultras\u00f3nicos por ADC. IMU conectada v\u00eda I2C.","title":"Configuraci\u00f3n de pines"},{"location":"configure/configure/#configuraciones-iniciales","text":"","title":"CONFIGURACIONES INICIALES"},{"location":"configure/configure/#libreria-config","text":"La librer\u00eda CONFIG contiene la configuraci\u00f3n de hardware para diferentes tipos de robots. Cada tipo tiene su propia estructura, que detalla los motores, sensores y perif\u00e9ricos necesarios para operar correctamente.","title":"Librer\u00eda CONFIG"},{"location":"configure/configure/#diccionario-de-configuracion","text":"CONFIG: Diccionario centralizado El diccionario CONFIG se utiliza para definir y seleccionar configuraciones predeterminadas de hardware. Las claves representan diferentes perfiles de robot. Puedes acceder a una configuraci\u00f3n espec\u00edfica as\u00ed: from config import CONFIG ROBOT_TYPE = \"mecanum\" config_actual = CONFIG [ ROBOT_TYPE ]","title":"\ud83d\udce6 Diccionario de configuraci\u00f3n"},{"location":"configure/configure/#configuraciones-disponibles","text":"CONFIG[\\\"mecanum\\\"] \u2013 Robot omnidireccional completo Configura un robot con 4 ruedas mecanum y sensores integrados. Control individual de 4 motores con PWM, direcci\u00f3n y encoders. 3 sensores ultras\u00f3nicos conectados a entradas anal\u00f3gicas (ADC). Sensor IMU conectado por I2C. Imagen: Robot mecanum con 4 ruedas omnidireccionales. CONFIG[\\\"arm\\\"] \u2013 Brazo rob\u00f3tico (4DOF) Configura un brazo rob\u00f3tico de 4 grados de libertad. 4 servomotores para articulaciones. Salida de control para efector final. Sensor ultras\u00f3nico para percepci\u00f3n frontal. Imagen: Brazo rob\u00f3tico de 4DOF. CONFIG[\\\"sensors\\\"] \u2013 Sensores independientes Configuraci\u00f3n para usar solo los sensores del sistema. 3 sensores ultras\u00f3nicos por ADC. IMU conectada v\u00eda I2C.","title":"\ud83e\udde9 Configuraciones disponibles"},{"location":"configure/motor_config_guide/","text":"Configuraci\u00f3n y Calibraci\u00f3n de Motores Ya tienes los archivos base en tu Pico W. El siguiente paso, y uno de los m\u00e1s importantes, es asegurar que cada motor de tu robot gire en la direcci\u00f3n correcta y que sus sensores de giro (encoders) lean correctamente. Esta gu\u00eda te ense\u00f1ar\u00e1 a diagnosticar y corregir el comportamiento de cada motor de forma individual. Requisitos Haber completado la Gu\u00eda 3: Carga de archivos base . Tu placa Raspberry Pi Pico W conectada a la computadora y con los archivos del proyecto ya cargados. El editor Thonny abierto y conectado a la Pico. Paso 1: Entender los Archivos de Configuraci\u00f3n El firmware separa la configuraci\u00f3n en dos archivos para proteger el hardware y darte flexibilidad: config.py : Contiene la configuraci\u00f3n base del hardware (pines, etc.). Este archivo NO debes modificarlo. student_config.py : Este es tu archivo de configuraci\u00f3n personal . Aqu\u00ed realizar\u00e1s todos los ajustes para tu robot espec\u00edfico. Dentro de student_config.py , puedes usar dos par\u00e1metros para cada motor para ajustar su comportamiento: \"inverted\": True : Invierte la direcci\u00f3n de giro f\u00edsico del motor. Si el motor deber\u00eda girar hacia adelante pero gira hacia atr\u00e1s, esta es la opci\u00f3n a usar. \"encoder_inverted\": True : Invierte la lectura del sensor de giro (encoder) , sin afectar el movimiento f\u00edsico del motor. Si el motor gira correctamente pero la consola muestra lecturas de posici\u00f3n incorrectas (por ejemplo, negativas cuando deber\u00eda ser positivas), esta es la opci\u00f3n a usar. Advertencia Importante La modificaci\u00f3n incorrecta de archivos puede causar un comportamiento inesperado o da\u00f1ar el hardware. Realiza todos los cambios exclusivamente en student_config.py . Aqu\u00ed tienes un esquema visual de los motores en un kit rob\u00f3tico para referencia: Imagen: Esquema de motores Paso 2: Preparar el Script de Diagn\u00f3stico Utilizaremos un script predefinido para probar cada motor de manera aislada. En Thonny, aseg\u00farate de que el panel de archivos est\u00e9 visible. Puedes activarlo desde el men\u00fa Ver > Archivos . En el panel de \"Este equipo\" (que representa tu computadora), navega hasta el directorio donde tienes guardado tu proyecto. Abre la carpeta student_examples . Busca el archivo 1_test_wheel_direction.py . Haz doble clic en \u00e9l para abrirlo en el editor de Thonny. Despl\u00e1zate hasta el final del script. Ver\u00e1s una l\u00ednea que llama a la funci\u00f3n test_wheel_direction() . Para empezar la prueba, aseg\u00farate de que est\u00e9 configurada para probar el primer motor. Modifica el par\u00e1metro motor_id a 0 : # Al final del archivo 1_test_wheel_direction.py test_wheel_direction ( robot , motor_id = 0 ) # motor_id va de 0 a 3, asumiendo 4 motores. La siguiente imagen muestra c\u00f3mo ejecutar este script y d\u00f3nde encontrar la l\u00ednea a modificar: Imagen: Ejecutando el archivo 1_test_wheel_direction.py Paso 3: Ejecutar la Prueba y Aplicar Correcciones Este es el ciclo principal de diagn\u00f3stico: ejecutar la prueba, observar el comportamiento y aplicar las correcciones necesarias en student_config.py . Ejecuta el script presionando el bot\u00f3n de \"Play\" (\u25b6) en la barra de herramientas de Thonny. Observa atentamente el movimiento de la rueda correspondiente al motor_id que est\u00e1s probando, y lee la informaci\u00f3n que aparece en la consola de Thonny. Compara lo que observas con los siguientes casos para determinar la correcci\u00f3n adecuada. Aqu\u00ed tienes una demostraci\u00f3n visual de la prueba en acci\u00f3n: Imagen: Comportamiento del robot durante la prueba del motor_id=0 Caso A: Funcionamiento Correcto \u2705 Observaci\u00f3n: La rueda gira primero hacia adelante y luego hacia atr\u00e1s. En la consola, las lecturas del encoder son positivas cuando el motor avanza y negativas cuando retrocede. Acci\u00f3n: \u00a1Excelente! El motor funciona correctamente. No necesitas hacer ninguna modificaci\u00f3n en student_config.py para este motor. Pasa a probar el siguiente motor cambiando el motor_id a 1 . Caso B: Motor con Giro F\u00edsico Invertido \ud83d\udd04 Observaci\u00f3n: La rueda gira en la direcci\u00f3n opuesta a la esperada (por ejemplo, gira hacia atr\u00e1s cuando deber\u00eda ir hacia adelante). Las lecturas del encoder, sin embargo, son consistentes con el movimiento deseado (positivas al intentar avanzar, negativas al intentar retroceder). Acci\u00f3n: Abre el archivo /config/student_config.py en Thonny. Localiza la lista MOTOR_DIRECTION . Si no existe, cr\u00e9ala. Para el motor que est\u00e1s probando (por ejemplo, el motor 0), a\u00f1ade la entrada {\"inverted\": True} a su diccionario. Si ya hay otras configuraciones, aseg\u00farate de mantenerlas. Guarda el archivo ( Ctrl+S o Cmd+S ). Vuelve a ejecutar el script 1_test_wheel_direction.py (asegur\u00e1ndote de que el motor_id sea el correcto) para confirmar que el problema se ha resuelto. # Ejemplo de modificaci\u00f3n en student_config.py MOTOR_DIRECTION = [ { \"inverted\" : True }, # Correcci\u00f3n para el Motor 0 # ... entradas para otros motores ] Caso C: Lectura del Encoder Invertida \ud83d\udcc8\ud83d\udcc9 Observaci\u00f3n: El movimiento f\u00edsico de la rueda es correcto (gira hacia adelante cuando se espera que avance), pero la consola muestra una lectura del encoder con el signo contrario (por ejemplo, lecturas negativas al avanzar y positivas al retroceder). Acci\u00f3n: Abre el archivo /config/student_config.py en Thonny. Localiza la lista MOTOR_DIRECTION . Para el motor que est\u00e1s probando, a\u00f1ade la entrada {\"encoder_inverted\": True} a su diccionario. Guarda el archivo y vuelve a ejecutar la prueba para verificar que la lectura del encoder ahora sea correcta. # Ejemplo de modificaci\u00f3n en student_config.py MOTOR_DIRECTION = [ { \"encoder_inverted\" : True }, # Correcci\u00f3n para el Motor 0 # ... entradas para otros motores ] Caso D: Giro F\u00edsico Invertido Y Lectura del Encoder Invertida Observaci\u00f3n: La rueda gira en la direcci\u00f3n opuesta a la esperada (hacia atr\u00e1s cuando deber\u00eda ir hacia adelante), Y las lecturas del encoder tambi\u00e9n son incorrectas (negativas al intentar avanzar, positivas al intentar retroceder). Acci\u00f3n: Abre el archivo /config/student_config.py . A\u00f1ade ambas configuraciones al diccionario del motor correspondiente: {\"inverted\": True, \"encoder_inverted\": True} . Guarda y verifica la correcci\u00f3n ejecutando el script de prueba. # Ejemplo de modificaci\u00f3n en student_config.py MOTOR_DIRECTION = [ { \"inverted\" : True , \"encoder_inverted\" : True }, # Correcci\u00f3n para el Motor 0 # ... entradas para otros motores ] Paso 4: Verificaci\u00f3n Final Una vez que hayas corregido el primer motor y confirmado que funciona correctamente, repite el Paso 3 para todos los dem\u00e1s motores de tu robot ( motor_id=1 , motor_id=2 , motor_id=3 , etc.). Al finalizar este proceso, tu archivo student_config.py contendr\u00e1 la configuraci\u00f3n personalizada y precisa para tu robot, asegurando que cada motor opere de la manera esperada. Un ejemplo de c\u00f3mo podr\u00eda verse tu student_config.py final para un robot de 4 ruedas, despu\u00e9s de haber aplicado las correcciones necesarias, ser\u00eda: # Ejemplo de una configuraci\u00f3n final para un robot de 4 ruedas MOTOR_DIRECTION = [ {}, # Motor 0: Operaba correctamente. { \"inverted\" : True }, # Motor 1: Requer\u00eda inversi\u00f3n de giro f\u00edsico. { \"encoder_inverted\" : True }, # Motor 2: Solo el encoder estaba invertido. { \"inverted\" : True , \"encoder_inverted\" : True }, # Motor 3: Giro y encoder invertidos. ] \u00a1Calibraci\u00f3n Completada! \u00a1Felicidades! Has completado con \u00e9xito la calibraci\u00f3n de los motores de tu robot. Con esta configuraci\u00f3n precisa, tu robot est\u00e1 listo para responder con exactitud en los pr\u00f3ximos laboratorios de movimiento y control.","title":"Configuraci\u00f3n y calibraci\u00f3n de motores"},{"location":"configure/motor_config_guide/#configuracion-y-calibracion-de-motores","text":"Ya tienes los archivos base en tu Pico W. El siguiente paso, y uno de los m\u00e1s importantes, es asegurar que cada motor de tu robot gire en la direcci\u00f3n correcta y que sus sensores de giro (encoders) lean correctamente. Esta gu\u00eda te ense\u00f1ar\u00e1 a diagnosticar y corregir el comportamiento de cada motor de forma individual. Requisitos Haber completado la Gu\u00eda 3: Carga de archivos base . Tu placa Raspberry Pi Pico W conectada a la computadora y con los archivos del proyecto ya cargados. El editor Thonny abierto y conectado a la Pico.","title":"Configuraci\u00f3n y Calibraci\u00f3n de Motores"},{"location":"configure/motor_config_guide/#paso-1-entender-los-archivos-de-configuracion","text":"El firmware separa la configuraci\u00f3n en dos archivos para proteger el hardware y darte flexibilidad: config.py : Contiene la configuraci\u00f3n base del hardware (pines, etc.). Este archivo NO debes modificarlo. student_config.py : Este es tu archivo de configuraci\u00f3n personal . Aqu\u00ed realizar\u00e1s todos los ajustes para tu robot espec\u00edfico. Dentro de student_config.py , puedes usar dos par\u00e1metros para cada motor para ajustar su comportamiento: \"inverted\": True : Invierte la direcci\u00f3n de giro f\u00edsico del motor. Si el motor deber\u00eda girar hacia adelante pero gira hacia atr\u00e1s, esta es la opci\u00f3n a usar. \"encoder_inverted\": True : Invierte la lectura del sensor de giro (encoder) , sin afectar el movimiento f\u00edsico del motor. Si el motor gira correctamente pero la consola muestra lecturas de posici\u00f3n incorrectas (por ejemplo, negativas cuando deber\u00eda ser positivas), esta es la opci\u00f3n a usar. Advertencia Importante La modificaci\u00f3n incorrecta de archivos puede causar un comportamiento inesperado o da\u00f1ar el hardware. Realiza todos los cambios exclusivamente en student_config.py . Aqu\u00ed tienes un esquema visual de los motores en un kit rob\u00f3tico para referencia: Imagen: Esquema de motores","title":"Paso 1: Entender los Archivos de Configuraci\u00f3n"},{"location":"configure/motor_config_guide/#paso-2-preparar-el-script-de-diagnostico","text":"Utilizaremos un script predefinido para probar cada motor de manera aislada. En Thonny, aseg\u00farate de que el panel de archivos est\u00e9 visible. Puedes activarlo desde el men\u00fa Ver > Archivos . En el panel de \"Este equipo\" (que representa tu computadora), navega hasta el directorio donde tienes guardado tu proyecto. Abre la carpeta student_examples . Busca el archivo 1_test_wheel_direction.py . Haz doble clic en \u00e9l para abrirlo en el editor de Thonny. Despl\u00e1zate hasta el final del script. Ver\u00e1s una l\u00ednea que llama a la funci\u00f3n test_wheel_direction() . Para empezar la prueba, aseg\u00farate de que est\u00e9 configurada para probar el primer motor. Modifica el par\u00e1metro motor_id a 0 : # Al final del archivo 1_test_wheel_direction.py test_wheel_direction ( robot , motor_id = 0 ) # motor_id va de 0 a 3, asumiendo 4 motores. La siguiente imagen muestra c\u00f3mo ejecutar este script y d\u00f3nde encontrar la l\u00ednea a modificar: Imagen: Ejecutando el archivo 1_test_wheel_direction.py","title":"Paso 2: Preparar el Script de Diagn\u00f3stico"},{"location":"configure/motor_config_guide/#paso-3-ejecutar-la-prueba-y-aplicar-correcciones","text":"Este es el ciclo principal de diagn\u00f3stico: ejecutar la prueba, observar el comportamiento y aplicar las correcciones necesarias en student_config.py . Ejecuta el script presionando el bot\u00f3n de \"Play\" (\u25b6) en la barra de herramientas de Thonny. Observa atentamente el movimiento de la rueda correspondiente al motor_id que est\u00e1s probando, y lee la informaci\u00f3n que aparece en la consola de Thonny. Compara lo que observas con los siguientes casos para determinar la correcci\u00f3n adecuada. Aqu\u00ed tienes una demostraci\u00f3n visual de la prueba en acci\u00f3n: Imagen: Comportamiento del robot durante la prueba del motor_id=0","title":"Paso 3: Ejecutar la Prueba y Aplicar Correcciones"},{"location":"configure/motor_config_guide/#caso-a-funcionamiento-correcto","text":"Observaci\u00f3n: La rueda gira primero hacia adelante y luego hacia atr\u00e1s. En la consola, las lecturas del encoder son positivas cuando el motor avanza y negativas cuando retrocede. Acci\u00f3n: \u00a1Excelente! El motor funciona correctamente. No necesitas hacer ninguna modificaci\u00f3n en student_config.py para este motor. Pasa a probar el siguiente motor cambiando el motor_id a 1 .","title":"Caso A: Funcionamiento Correcto \u2705"},{"location":"configure/motor_config_guide/#caso-b-motor-con-giro-fisico-invertido","text":"Observaci\u00f3n: La rueda gira en la direcci\u00f3n opuesta a la esperada (por ejemplo, gira hacia atr\u00e1s cuando deber\u00eda ir hacia adelante). Las lecturas del encoder, sin embargo, son consistentes con el movimiento deseado (positivas al intentar avanzar, negativas al intentar retroceder). Acci\u00f3n: Abre el archivo /config/student_config.py en Thonny. Localiza la lista MOTOR_DIRECTION . Si no existe, cr\u00e9ala. Para el motor que est\u00e1s probando (por ejemplo, el motor 0), a\u00f1ade la entrada {\"inverted\": True} a su diccionario. Si ya hay otras configuraciones, aseg\u00farate de mantenerlas. Guarda el archivo ( Ctrl+S o Cmd+S ). Vuelve a ejecutar el script 1_test_wheel_direction.py (asegur\u00e1ndote de que el motor_id sea el correcto) para confirmar que el problema se ha resuelto. # Ejemplo de modificaci\u00f3n en student_config.py MOTOR_DIRECTION = [ { \"inverted\" : True }, # Correcci\u00f3n para el Motor 0 # ... entradas para otros motores ]","title":"Caso B: Motor con Giro F\u00edsico Invertido \ud83d\udd04"},{"location":"configure/motor_config_guide/#caso-c-lectura-del-encoder-invertida","text":"Observaci\u00f3n: El movimiento f\u00edsico de la rueda es correcto (gira hacia adelante cuando se espera que avance), pero la consola muestra una lectura del encoder con el signo contrario (por ejemplo, lecturas negativas al avanzar y positivas al retroceder). Acci\u00f3n: Abre el archivo /config/student_config.py en Thonny. Localiza la lista MOTOR_DIRECTION . Para el motor que est\u00e1s probando, a\u00f1ade la entrada {\"encoder_inverted\": True} a su diccionario. Guarda el archivo y vuelve a ejecutar la prueba para verificar que la lectura del encoder ahora sea correcta. # Ejemplo de modificaci\u00f3n en student_config.py MOTOR_DIRECTION = [ { \"encoder_inverted\" : True }, # Correcci\u00f3n para el Motor 0 # ... entradas para otros motores ]","title":"Caso C: Lectura del Encoder Invertida \ud83d\udcc8\ud83d\udcc9"},{"location":"configure/motor_config_guide/#caso-d-giro-fisico-invertido-y-lectura-del-encoder-invertida","text":"Observaci\u00f3n: La rueda gira en la direcci\u00f3n opuesta a la esperada (hacia atr\u00e1s cuando deber\u00eda ir hacia adelante), Y las lecturas del encoder tambi\u00e9n son incorrectas (negativas al intentar avanzar, positivas al intentar retroceder). Acci\u00f3n: Abre el archivo /config/student_config.py . A\u00f1ade ambas configuraciones al diccionario del motor correspondiente: {\"inverted\": True, \"encoder_inverted\": True} . Guarda y verifica la correcci\u00f3n ejecutando el script de prueba. # Ejemplo de modificaci\u00f3n en student_config.py MOTOR_DIRECTION = [ { \"inverted\" : True , \"encoder_inverted\" : True }, # Correcci\u00f3n para el Motor 0 # ... entradas para otros motores ]","title":"Caso D: Giro F\u00edsico Invertido Y Lectura del Encoder Invertida"},{"location":"configure/motor_config_guide/#paso-4-verificacion-final","text":"Una vez que hayas corregido el primer motor y confirmado que funciona correctamente, repite el Paso 3 para todos los dem\u00e1s motores de tu robot ( motor_id=1 , motor_id=2 , motor_id=3 , etc.). Al finalizar este proceso, tu archivo student_config.py contendr\u00e1 la configuraci\u00f3n personalizada y precisa para tu robot, asegurando que cada motor opere de la manera esperada. Un ejemplo de c\u00f3mo podr\u00eda verse tu student_config.py final para un robot de 4 ruedas, despu\u00e9s de haber aplicado las correcciones necesarias, ser\u00eda: # Ejemplo de una configuraci\u00f3n final para un robot de 4 ruedas MOTOR_DIRECTION = [ {}, # Motor 0: Operaba correctamente. { \"inverted\" : True }, # Motor 1: Requer\u00eda inversi\u00f3n de giro f\u00edsico. { \"encoder_inverted\" : True }, # Motor 2: Solo el encoder estaba invertido. { \"inverted\" : True , \"encoder_inverted\" : True }, # Motor 3: Giro y encoder invertidos. ] \u00a1Calibraci\u00f3n Completada! \u00a1Felicidades! Has completado con \u00e9xito la calibraci\u00f3n de los motores de tu robot. Con esta configuraci\u00f3n precisa, tu robot est\u00e1 listo para responder con exactitud en los pr\u00f3ximos laboratorios de movimiento y control.","title":"Paso 4: Verificaci\u00f3n Final"},{"location":"guides/base_guide/","text":"Gu\u00eda 3: Carga de archivos base y librer\u00edas para el robot (Pico W) Ya tenemos Thonny funcionando y la Pico W con el firmware instalado. Ahora cargaremos un conjunto de archivos esenciales que contienen funciones, librer\u00edas y configuraciones necesarias para controlar tu robot. Requisitos Haber completado la Gu\u00eda 2: Tu primer programa con Thonny . Tu placa Raspberry Pi Pico W conectada a la computadora. Un cable de datos micro-USB. Acceso al archivo .zip con los archivos del robot. Paso 1: Descargar los archivos base del robot Hemos preparado un paquete que contiene todos los archivos y carpetas necesarias para que tu robot funcione correctamente. Descarga el archivo .zip desde el siguiente enlace: \ud83d\udce6 Descargar archivos base del robot Una vez descargado, extrae (descomprime) el contenido. Ver\u00e1s una carpeta que contiene subcarpetas como: Imagen: Distribuci\u00f3n de carpetas Paso 2: Abrir Thonny y conectar la placa Abre el editor Thonny . Conecta tu Raspberry Pi Pico W a la computadora ( sin presionar BOOTSEL ). Aseg\u00farate de que en la parte inferior derecha de Thonny est\u00e9 seleccionado: MicroPython (Raspberry Pi Pico) Imagen: Distribuci\u00f3n de carpetas Paso 3: Cargar y Verificar los Archivos en la Pico W En este paso, copiaremos las carpetas del proyecto desde tu computadora a la memoria de la Pico W. En Thonny, ve al men\u00fa Ver > Archivos para mostrar el explorador de archivos si no est\u00e1 visible. En el panel izquierdo ( \"Este equipo\" ), navega hasta la carpeta que descomprimiste en el Paso 1. Selecciona todo el contenido de la carpeta (las subcarpetas config , libraries , robot , sensors , utils , etc.). Para seleccionar varios elementos, mant\u00e9n presionada la tecla Ctrl (o Cmd en Mac) y haz clic en cada uno. Haz clic derecho sobre los elementos seleccionados y elige la opci\u00f3n Subir a / . Thonny comenzar\u00e1 la carga. Una vez finalizada, verifica que en el panel derecho ( \"Raspberry Pi Pico\" ) aparezcan las carpetas que acabas de subir. La estructura debe verse as\u00ed: Imagen: Proceso de subir las carpetas del proyecto a la Pico W. Sube el contenido, no la carpeta contenedora Es crucial que subas las carpetas config , libraries , etc., directamente a la ra\u00edz ( / ) de la Pico. No subas la carpeta principal que las contiene. Paso 4: Ejecutar Prueba de Verificaci\u00f3n (Opcional) Para confirmar que la Pico reconoce correctamente los archivos, puedes ejecutar un peque\u00f1o script. Copia y pega el siguiente c\u00f3digo en el editor principal de Thonny: import os print ( \" \\n ----------Archivos en la Pico:------------ \\n \" ) print ( os . listdir ()) print ( \" \\n ------------------------------------------ \\n \" ) Presiona F5 o el bot\u00f3n de Ejecutar (\u25b6). En la consola (Shell) de Thonny, deber\u00edas ver una lista que incluye los nombres de las carpetas que subiste. Imagen: Validando la carga de archivos mediante un script. \u00a1Carga completada! Ya tienes listo el entorno de archivos en tu Raspberry Pi Pico W. Esto te permitir\u00e1 controlar sensores, motores, y ejecutar programas complejos para tu robot. En las siguientes gu\u00edas empezaremos a usar estas librer\u00edas para mover el robot, leer sensores y m\u00e1s.","title":"Gu\u00eda 3: Carga de archivos base"},{"location":"guides/base_guide/#guia-3-carga-de-archivos-base-y-librerias-para-el-robot-pico-w","text":"Ya tenemos Thonny funcionando y la Pico W con el firmware instalado. Ahora cargaremos un conjunto de archivos esenciales que contienen funciones, librer\u00edas y configuraciones necesarias para controlar tu robot. Requisitos Haber completado la Gu\u00eda 2: Tu primer programa con Thonny . Tu placa Raspberry Pi Pico W conectada a la computadora. Un cable de datos micro-USB. Acceso al archivo .zip con los archivos del robot.","title":"Gu\u00eda 3: Carga de archivos base y librer\u00edas para el robot (Pico W)"},{"location":"guides/base_guide/#paso-1-descargar-los-archivos-base-del-robot","text":"Hemos preparado un paquete que contiene todos los archivos y carpetas necesarias para que tu robot funcione correctamente. Descarga el archivo .zip desde el siguiente enlace: \ud83d\udce6 Descargar archivos base del robot Una vez descargado, extrae (descomprime) el contenido. Ver\u00e1s una carpeta que contiene subcarpetas como: Imagen: Distribuci\u00f3n de carpetas","title":"Paso 1: Descargar los archivos base del robot"},{"location":"guides/base_guide/#paso-2-abrir-thonny-y-conectar-la-placa","text":"Abre el editor Thonny . Conecta tu Raspberry Pi Pico W a la computadora ( sin presionar BOOTSEL ). Aseg\u00farate de que en la parte inferior derecha de Thonny est\u00e9 seleccionado: MicroPython (Raspberry Pi Pico) Imagen: Distribuci\u00f3n de carpetas","title":"Paso 2: Abrir Thonny y conectar la placa"},{"location":"guides/base_guide/#paso-3-cargar-y-verificar-los-archivos-en-la-pico-w","text":"En este paso, copiaremos las carpetas del proyecto desde tu computadora a la memoria de la Pico W. En Thonny, ve al men\u00fa Ver > Archivos para mostrar el explorador de archivos si no est\u00e1 visible. En el panel izquierdo ( \"Este equipo\" ), navega hasta la carpeta que descomprimiste en el Paso 1. Selecciona todo el contenido de la carpeta (las subcarpetas config , libraries , robot , sensors , utils , etc.). Para seleccionar varios elementos, mant\u00e9n presionada la tecla Ctrl (o Cmd en Mac) y haz clic en cada uno. Haz clic derecho sobre los elementos seleccionados y elige la opci\u00f3n Subir a / . Thonny comenzar\u00e1 la carga. Una vez finalizada, verifica que en el panel derecho ( \"Raspberry Pi Pico\" ) aparezcan las carpetas que acabas de subir. La estructura debe verse as\u00ed: Imagen: Proceso de subir las carpetas del proyecto a la Pico W. Sube el contenido, no la carpeta contenedora Es crucial que subas las carpetas config , libraries , etc., directamente a la ra\u00edz ( / ) de la Pico. No subas la carpeta principal que las contiene.","title":"Paso 3: Cargar y Verificar los Archivos en la Pico W"},{"location":"guides/base_guide/#paso-4-ejecutar-prueba-de-verificacion-opcional","text":"Para confirmar que la Pico reconoce correctamente los archivos, puedes ejecutar un peque\u00f1o script. Copia y pega el siguiente c\u00f3digo en el editor principal de Thonny: import os print ( \" \\n ----------Archivos en la Pico:------------ \\n \" ) print ( os . listdir ()) print ( \" \\n ------------------------------------------ \\n \" ) Presiona F5 o el bot\u00f3n de Ejecutar (\u25b6). En la consola (Shell) de Thonny, deber\u00edas ver una lista que incluye los nombres de las carpetas que subiste. Imagen: Validando la carga de archivos mediante un script. \u00a1Carga completada! Ya tienes listo el entorno de archivos en tu Raspberry Pi Pico W. Esto te permitir\u00e1 controlar sensores, motores, y ejecutar programas complejos para tu robot. En las siguientes gu\u00edas empezaremos a usar estas librer\u00edas para mover el robot, leer sensores y m\u00e1s.","title":"Paso 4: Ejecutar Prueba de Verificaci\u00f3n (Opcional)"},{"location":"guides/micropython_guide/","text":"Gu\u00eda 1: Instalaci\u00f3n del firmware de la Raspberry Pi Pico W Sigue estos tres pasos para preparar tu placa Raspberry Pi Pico W para los laboratorio. Requisitos Una placa Raspberry Pi Pico W . Un cable de datos micro-USB. El editor Thonny IDE instalado. Paso 1: Descargar el firmware Primero, obt\u00e9n el archivo de firmware oficial de MicroPython, descargar la \u00faltima versi\u00f3n del firmware. Firmware MicroPython para Pico W (.uf2) Guarda este archivo en tu escritorio o en un lugar f\u00e1cil de encontrar. Paso 2: Instalar el firmware en la placa Ahora, vamos a \"flashear\" el firmware en la memoria del Pico. Mant\u00e9n presionado el bot\u00f3n BOOTSEL de tu Pico. Imagen: Bot\u00f3n BOOTSEL Sin soltarlo , conecta el Pico a tu computadora. Aparecer\u00e1 una unidad llamada RPI-RP2 . Ahora suelta el bot\u00f3n BOOTSEL . Imagen: Unidad RPI-RP2 ! 4. Arrastra y suelta el archivo .uf2 que descargaste sobre esa unidad RPI-RP2 . \u00a1Firmware Instalado! La placa se reiniciar\u00e1 sola y la unidad RPI-RP2 desaparecer\u00e1 de tu explorador de archivos. Esto es normal y significa que la instalaci\u00f3n fue exitosa. \u00a1Listo! Tu placa ya tiene MicroPython instalado. Ahora est\u00e1s listo para continuar con la siguiente gu\u00eda: programarla usando Thonny .","title":"Gu\u00eda 1: Instalaci\u00f3n del firmware del Micropython"},{"location":"guides/micropython_guide/#guia-1-instalacion-del-firmware-de-la-raspberry-pi-pico-w","text":"Sigue estos tres pasos para preparar tu placa Raspberry Pi Pico W para los laboratorio. Requisitos Una placa Raspberry Pi Pico W . Un cable de datos micro-USB. El editor Thonny IDE instalado.","title":"Gu\u00eda 1: Instalaci\u00f3n del firmware de la Raspberry Pi Pico W"},{"location":"guides/micropython_guide/#paso-1-descargar-el-firmware","text":"Primero, obt\u00e9n el archivo de firmware oficial de MicroPython, descargar la \u00faltima versi\u00f3n del firmware. Firmware MicroPython para Pico W (.uf2) Guarda este archivo en tu escritorio o en un lugar f\u00e1cil de encontrar.","title":"Paso 1: Descargar el firmware"},{"location":"guides/micropython_guide/#paso-2-instalar-el-firmware-en-la-placa","text":"Ahora, vamos a \"flashear\" el firmware en la memoria del Pico. Mant\u00e9n presionado el bot\u00f3n BOOTSEL de tu Pico. Imagen: Bot\u00f3n BOOTSEL Sin soltarlo , conecta el Pico a tu computadora. Aparecer\u00e1 una unidad llamada RPI-RP2 . Ahora suelta el bot\u00f3n BOOTSEL . Imagen: Unidad RPI-RP2 ! 4. Arrastra y suelta el archivo .uf2 que descargaste sobre esa unidad RPI-RP2 . \u00a1Firmware Instalado! La placa se reiniciar\u00e1 sola y la unidad RPI-RP2 desaparecer\u00e1 de tu explorador de archivos. Esto es normal y significa que la instalaci\u00f3n fue exitosa.","title":"Paso 2: Instalar el firmware en la placa"},{"location":"guides/micropython_guide/#listo","text":"Tu placa ya tiene MicroPython instalado. Ahora est\u00e1s listo para continuar con la siguiente gu\u00eda: programarla usando Thonny .","title":"\u00a1Listo!"},{"location":"guides/thony_guide/","text":"Gu\u00eda 2: Tu primer programa con Thonny Ahora que tu placa tiene el firmware, vamos a comprobar que todo funciona correctamente. Para ello, instalaremos el editor Thonny y ejecutaremos un c\u00f3digo que haga parpadear el LED de la placa. Requisitos Haber completado la Gu\u00eda 1: Instalaci\u00f3n del Firmware . Tu placa Raspberry Pi Pico W (ya con el firmware). Un cable de datos micro-USB. Paso 1: Instalar el editor Thonny Thonny es el Entorno de Desarrollo Integrado (IDE) que usaremos. Es perfecto para principiantes porque es sencillo e incluye todo lo necesario para programar la Pico. Descarga Thonny desde su p\u00e1gina oficial: https://thonny.org/ Instala el programa en tu computadora siguiendo los pasos del asistente. Paso 2: Conectar la placa a Thonny Abre Thonny . Conecta tu Raspberry Pi Pico W a la computadora (esta vez de forma normal, sin presionar BOOTSEL ). En la esquina inferior derecha de Thonny, haz clic y aseg\u00farate de que est\u00e9 seleccionado el int\u00e9rprete MicroPython (Raspberry Pi Pico) . Si no aparece, desconecta y vuelve a conectar la placa. Imagen: Selecci\u00f3n del int\u00e9rprete MicroPython (Raspberry Pi Pico) en Thonny. Paso 3: C\u00f3digo de prueba (LED intermitente) Vamos a escribir y ejecutar nuestro primer programa para verificar la conexi\u00f3n. Copia el siguiente c\u00f3digo y p\u00e9galo en la ventana principal del editor de Thonny (donde dice <untitled> ). # Importamos las herramientas necesarias from machine import Pin from time import sleep # Configuramos el pin del LED integrado como una salida. # En la Pico W, el LED se llama 'LED'. led = Pin ( 'LED' , Pin . OUT ) # Creamos un bucle infinito para que el programa se repita sin parar while True : led . on () # Encender el LED sleep ( 1 ) # Esperar 1 segundo led . off () # Apagar el LED sleep ( 1 ) # Esperar 1 segundo Haz clic en el bot\u00f3n verde de \"Play\" (\u25b6) o presiona la tecla F5 para ejecutar el c\u00f3digo. Imagen: LED intermitente \u00a1Verificaci\u00f3n Exitosa! Si todo sali\u00f3 bien, el LED verde integrado en tu Pico W comenzar\u00e1 a parpadear (se enciende por un segundo y se apaga por un segundo). \u00a1Felicidades, has ejecutado tu primer programa! Para detenerlo, haz clic en el bot\u00f3n rojo de \"Stop\" (\u25a0) en Thonny. Paso 4 (Opcional pero recomendado): Guardar el c\u00f3digo en la placa Para que tu programa se ejecute autom\u00e1ticamente cada vez que conectes la placa (sin necesidad de una computadora), gu\u00e1rdalo con el nombre main.py . Ve a Archivo > Guardar como... ( File > Save as... ). Elige guardar en Raspberry Pi Pico . Nombra el archivo exactamente como main.py y haz clic en OK . Imagen: Guardar c\u00f3digo main.py en la raspberry pi pico W El poder de main.py Cualquier c\u00f3digo guardado como main.py en la memoria de la Pico se ejecutar\u00e1 autom\u00e1ticamente al encenderla. \u00a1Listo! Has completado la configuraci\u00f3n inicial y verificado que puedes comunicarte con tu Pico W. Ahora est\u00e1s listo para continuar con la siguiente gu\u00eda: Gu\u00eda 3: Cargar los archivos base del robot .","title":"Gu\u00eda 2: Tu primer programa con Thonny"},{"location":"guides/thony_guide/#guia-2-tu-primer-programa-con-thonny","text":"Ahora que tu placa tiene el firmware, vamos a comprobar que todo funciona correctamente. Para ello, instalaremos el editor Thonny y ejecutaremos un c\u00f3digo que haga parpadear el LED de la placa. Requisitos Haber completado la Gu\u00eda 1: Instalaci\u00f3n del Firmware . Tu placa Raspberry Pi Pico W (ya con el firmware). Un cable de datos micro-USB.","title":"Gu\u00eda 2: Tu primer programa con Thonny"},{"location":"guides/thony_guide/#paso-1-instalar-el-editor-thonny","text":"Thonny es el Entorno de Desarrollo Integrado (IDE) que usaremos. Es perfecto para principiantes porque es sencillo e incluye todo lo necesario para programar la Pico. Descarga Thonny desde su p\u00e1gina oficial: https://thonny.org/ Instala el programa en tu computadora siguiendo los pasos del asistente.","title":"Paso 1: Instalar el editor Thonny"},{"location":"guides/thony_guide/#paso-2-conectar-la-placa-a-thonny","text":"Abre Thonny . Conecta tu Raspberry Pi Pico W a la computadora (esta vez de forma normal, sin presionar BOOTSEL ). En la esquina inferior derecha de Thonny, haz clic y aseg\u00farate de que est\u00e9 seleccionado el int\u00e9rprete MicroPython (Raspberry Pi Pico) . Si no aparece, desconecta y vuelve a conectar la placa. Imagen: Selecci\u00f3n del int\u00e9rprete MicroPython (Raspberry Pi Pico) en Thonny.","title":"Paso 2: Conectar la placa a Thonny"},{"location":"guides/thony_guide/#paso-3-codigo-de-prueba-led-intermitente","text":"Vamos a escribir y ejecutar nuestro primer programa para verificar la conexi\u00f3n. Copia el siguiente c\u00f3digo y p\u00e9galo en la ventana principal del editor de Thonny (donde dice <untitled> ). # Importamos las herramientas necesarias from machine import Pin from time import sleep # Configuramos el pin del LED integrado como una salida. # En la Pico W, el LED se llama 'LED'. led = Pin ( 'LED' , Pin . OUT ) # Creamos un bucle infinito para que el programa se repita sin parar while True : led . on () # Encender el LED sleep ( 1 ) # Esperar 1 segundo led . off () # Apagar el LED sleep ( 1 ) # Esperar 1 segundo Haz clic en el bot\u00f3n verde de \"Play\" (\u25b6) o presiona la tecla F5 para ejecutar el c\u00f3digo. Imagen: LED intermitente \u00a1Verificaci\u00f3n Exitosa! Si todo sali\u00f3 bien, el LED verde integrado en tu Pico W comenzar\u00e1 a parpadear (se enciende por un segundo y se apaga por un segundo). \u00a1Felicidades, has ejecutado tu primer programa! Para detenerlo, haz clic en el bot\u00f3n rojo de \"Stop\" (\u25a0) en Thonny.","title":"Paso 3: C\u00f3digo de prueba (LED intermitente)"},{"location":"guides/thony_guide/#paso-4-opcional-pero-recomendado-guardar-el-codigo-en-la-placa","text":"Para que tu programa se ejecute autom\u00e1ticamente cada vez que conectes la placa (sin necesidad de una computadora), gu\u00e1rdalo con el nombre main.py . Ve a Archivo > Guardar como... ( File > Save as... ). Elige guardar en Raspberry Pi Pico . Nombra el archivo exactamente como main.py y haz clic en OK . Imagen: Guardar c\u00f3digo main.py en la raspberry pi pico W El poder de main.py Cualquier c\u00f3digo guardado como main.py en la memoria de la Pico se ejecutar\u00e1 autom\u00e1ticamente al encenderla.","title":"Paso 4 (Opcional pero recomendado): Guardar el c\u00f3digo en la placa"},{"location":"guides/thony_guide/#listo","text":"Has completado la configuraci\u00f3n inicial y verificado que puedes comunicarte con tu Pico W. Ahora est\u00e1s listo para continuar con la siguiente gu\u00eda: Gu\u00eda 3: Cargar los archivos base del robot .","title":"\u00a1Listo!"},{"location":"robot/robot/","text":"Clase robot Antes de iniciar el proyecto, es necesario definir la clase base del robot que se utilizar\u00e1. Esta clase debe ser capaz de manejar diferentes configuraciones de hardware y proporcionar una interfaz com\u00fan para interactuar con los motores y sensores. PASO 1: Definir la clase base del robot En primer lugar, es necesario importar el m\u00e9todo get_robot de la librer\u00eda robot . Este m\u00e9todo permite obtener una instancia del robot seg\u00fan el tipo de robot y su configuraci\u00f3n. Cada configuraci\u00f3n depende del tipo de robot, por lo que se sugiere revisar la documentaci\u00f3n de configure para entender las diferentes configuraciones disponibles. A continuaci\u00f3n se muestra un ejemplo de c\u00f3mo definir la clase base del robot utilizando el m\u00e9todo get_robot para crear una instancia del robot mecanum: Ejemplo de inicializaci\u00f3n Este bloque de c\u00f3digo crea una instancia del robot tipo mecanum usando la configuraci\u00f3n definida en CONFIG : from config import CONFIG from robot import get_robot ROBOT_TYPE = 'mecanum' robot = get_robot ( ROBOT_TYPE , CONFIG [ ROBOT_TYPE ]) PASO 2: Controlar el robot Luego de llamar a get_robot , se puede utilizar la instancia del robot para controlar sus motores y sensores. Por ejemplo: Ejemplo de uso de metodo move robot . move ( vx = 0.5 , vy = 0.0 , omega = 0.1 ) M\u00e9todos asociados a la clase base del robot Funciones relacionadas con el movimiento del robot ROBOT.MOVE robot.move(vx, vy, omega) Calcula y aplica velocidades individuales a las ruedas a partir de velocidades del chasis. Par\u00e1metros: vx ( float ): Velocidad lineal en eje X [m/s] vy ( float ): Velocidad lineal en eje Y [m/s] omega ( float ): Velocidad angular del chasis [rad/s] Ejemplo: Ejemplo de uso de metodo move Este comando permite mover el robot con una velocidad lineal de 0.5\u202fm/s en el eje X, sin movimiento en el eje Y, y con una rotaci\u00f3n angular de 0.1\u202frad/s. robot . move ( vx = 0.5 , vy = 0.0 , omega = 0.1 ) ROBOT.STOP robot.stop() Detiene el robot m\u00f3vil, estableciendo todas las velocidades a cero. Ejemplo de uso de metodo stop Este comando detiene completamente el movimiento del robot. robot . stop () ROBOT.SET_CUSTOM_JACOBIAN robot.set_custom_jacobian(func) Define una funci\u00f3n externa para calcular el jacobiano personalizado. Par\u00e1metros: func ( callable ): Funci\u00f3n que retorna una matriz jacobiana (lista de listas) Ejemplo de uso de metodo set_custom_jacobian Este comando permite definir un jacobiano personalizado para el robot, \u00fatil en aplicaciones espec\u00edficas. def my_jacobian (): return [[ 1 , 0 , - 1 ], [ 1 , 0 , 1 ], [ 1 , 0 , 1 ], [ 1 , 0 , - 1 ]] robot . set_custom_jacobian ( my_jacobian ) Funciones relacionadas con el control en lazo cerrado ROBOT.SET_CONTROL_MODE robot.set_control_mode(closed_loop=False) Activa o desactiva el control en lazo cerrado (PID) en todos los motores. Par\u00e1metros: closed_loop ( bool ): True para habilitar PID, False para desactivar Ejemplo de uso de metodo set_control_mode Este comando activa el control PID en todos los motores del robot. robot . set_control_mode ( closed_loop = True ) ROBOT.SET_PID_CONSTANTS robot.set_pid_constants(motor_index, kp, ki=None, kd=None) Configura los par\u00e1metros PID de un motor en espec\u00edfico. Par\u00e1metros: motor_index ( int ): \u00cdndice del motor en la lista robot.motors kp ( float ): Constante proporcional ki ( float ): Constante integral (opcional) kd ( float ): Constante derivativa (opcional) Ejemplo de uso de metodo set_pid_constants Este comando ajusta los par\u00e1metros PID del primer motor del robot. robot . set_pid_constants ( motor_index = 0 , kp = 1.2 , ki = 0.5 , kd = 0.05 ) ROBOT.ENABLE_AUTO_UPDATE robot.enable_auto_update(interval=10) Habilita la actualizaci\u00f3n peri\u00f3dica de los motores usando un Timer . Par\u00e1metros: interval ( int ): Periodo de actualizaci\u00f3n en milisegundos (por defecto 10 ms) Ejemplo de uso de metodo enable_auto_update Este comando activa la actualizaci\u00f3n autom\u00e1tica de los motores cada 20 ms. robot . enable_auto_update ( interval = 20 ) Funciones relacionadas con los motores individuales ROBOT.MOTORS.ID.SET_SPEED robot.motors[id].set_speed(speed_rps) Establece la velocidad objetivo del motor en revoluciones por segundo (rps). Ejemplo de uso de metodo set_speed Este comando establece la velocidad del primer motor a 10.0 rps. robot . motors [ 0 ] . set_speed ( 10.0 ) ROBOT.MOTORS.ID.STOP robot.motors[id].stop() Detiene el motor individual. Ejemplo de uso de metodo stop Este comando detiene el segundo motor del robot. robot . motors [ 1 ] . stop () ROBOT.MOTORS.ID.GET_SPEED robot.motors[id].get_speed() Retorna la velocidad actual del motor. Ejemplo de uso de metodo get_speed Este comando obtiene la velocidad actual del tercer motor. vel = robot . motors [ 2 ] . get_speed () ROBOT.MOTORS.ID.GET_STATE robot.motors[id].get_state() Retorna un diccionario con informaci\u00f3n del estado del motor (velocidad, posici\u00f3n, PID, etc). Ejemplo de uso de metodo get_state Este comando imprime el estado del cuarto motor, incluyendo velocidad y posici\u00f3n. print ( robot . motors [ 3 ] . get_state ()) ROBOT.MOTORS.ID.ENABLE_CLOSE_LOOP_CONTROL robot.motors[id].enable_close_loop_control(True) Activa el control PID para ese motor. Ejemplo de uso de metodo enable_close_loop_control Este comando activa el control PID en el primer motor del robot. robot . motors [ 0 ] . enable_close_loop_control ( True ) ROBOT.MOTORS.ID.TUNE_PID robot.motors[id].tune_pid(kp, ki, kd) Ajusta los par\u00e1metros PID para un motor espec\u00edfico. Ejemplo de uso de metodo tune_pid Este comando ajusta los par\u00e1metros PID del primer motor a kp=1.0, ki=0.1, kd=0.01. robot . motors [ 0 ] . tune_pid ( kp = 1.0 , ki = 0.1 , kd = 0.01 ) Funciones relacionadas con la lectura de sensores del robot ROBOT.SENSORS.READ_IMU_THETA robot.sensors.read_imu_theta() Devuelve el \u00e1ngulo de orientaci\u00f3n estimado por el IMU (en radianes). Ejemplo de uso de metodo read_imu_theta Este comando obtiene el \u00e1ngulo de orientaci\u00f3n del robot desde el IMU. theta = robot . sensors . read_imu_theta () ROBOT.SENSORS.READ_IMU_VALUES robot.sensors.read_imu_values() Retorna los valores del IMU (aceler\u00f3metro y gir\u00f3scopo). Ejemplo de uso de metodo read_imu_values Este comando obtiene los valores del IMU, incluyendo aceleraci\u00f3n y velocidad angular. imu_data = robot . sensors . read_imu_values () ROBOT.SENSORS.READ_ULTRASONIC_VALUE robot.sensors.read_ultrasonic_value(sensor_id) Retorna la distancia medida por un sensor ultras\u00f3nico espec\u00edfico. Ejemplo de uso de metodo read_ultrasonic_value Este comando obtiene la distancia medida por el primer sensor ultras\u00f3nico. distancia = robot . sensors . read_ultrasonic_value ( sensor_id = 0 ) ROBOT.SENSORS.READ_ULTRASONIC_ALL robot.sensors.read_ultrasonic_all() Retorna una lista con las mediciones de todos los sensores ultras\u00f3nicos. Ejemplo de uso de metodo read_ultrasonic_all Este comando obtiene las distancias medidas por todos los sensores ultras\u00f3nicos del robot. distancias = robot . sensors . read_ultrasonic_all () ROBOT.UPDATE_ODOMETRY robot.update_odometry() Actualiza la posici\u00f3n estimada del robot. Actualmente no implementado, pero reservado para fusi\u00f3n de datos de encoders e IMU. Ejemplo de uso de metodo update_odometry Este comando actualiza la odometr\u00eda del robot, aunque actualmente no realiza ninguna acci\u00f3n. robot . update_odometry () ROBOT.MOTORS robot.motors Lista de objetos MotorWithPID que representan cada una de las ruedas del robot. Ejemplo de uso de la lista robot.motors Este comando itera sobre cada motor del robot e imprime su estado actual. for motor in robot . motors : print ( motor . get_state ())","title":"Robot"},{"location":"robot/robot/#clase-robot","text":"Antes de iniciar el proyecto, es necesario definir la clase base del robot que se utilizar\u00e1. Esta clase debe ser capaz de manejar diferentes configuraciones de hardware y proporcionar una interfaz com\u00fan para interactuar con los motores y sensores.","title":"Clase robot"},{"location":"robot/robot/#paso-1-definir-la-clase-base-del-robot","text":"En primer lugar, es necesario importar el m\u00e9todo get_robot de la librer\u00eda robot . Este m\u00e9todo permite obtener una instancia del robot seg\u00fan el tipo de robot y su configuraci\u00f3n. Cada configuraci\u00f3n depende del tipo de robot, por lo que se sugiere revisar la documentaci\u00f3n de configure para entender las diferentes configuraciones disponibles. A continuaci\u00f3n se muestra un ejemplo de c\u00f3mo definir la clase base del robot utilizando el m\u00e9todo get_robot para crear una instancia del robot mecanum: Ejemplo de inicializaci\u00f3n Este bloque de c\u00f3digo crea una instancia del robot tipo mecanum usando la configuraci\u00f3n definida en CONFIG : from config import CONFIG from robot import get_robot ROBOT_TYPE = 'mecanum' robot = get_robot ( ROBOT_TYPE , CONFIG [ ROBOT_TYPE ])","title":"PASO 1: Definir la clase base del robot"},{"location":"robot/robot/#paso-2-controlar-el-robot","text":"Luego de llamar a get_robot , se puede utilizar la instancia del robot para controlar sus motores y sensores. Por ejemplo: Ejemplo de uso de metodo move robot . move ( vx = 0.5 , vy = 0.0 , omega = 0.1 )","title":"PASO 2: Controlar el robot"},{"location":"robot/robot/#metodos-asociados-a-la-clase-base-del-robot","text":"","title":"M\u00e9todos asociados a la clase base del robot"},{"location":"robot/robot/#funciones-relacionadas-con-el-movimiento-del-robot","text":"","title":"Funciones relacionadas con el movimiento del robot"},{"location":"robot/robot/#robotmove","text":"robot.move(vx, vy, omega) Calcula y aplica velocidades individuales a las ruedas a partir de velocidades del chasis. Par\u00e1metros: vx ( float ): Velocidad lineal en eje X [m/s] vy ( float ): Velocidad lineal en eje Y [m/s] omega ( float ): Velocidad angular del chasis [rad/s] Ejemplo: Ejemplo de uso de metodo move Este comando permite mover el robot con una velocidad lineal de 0.5\u202fm/s en el eje X, sin movimiento en el eje Y, y con una rotaci\u00f3n angular de 0.1\u202frad/s. robot . move ( vx = 0.5 , vy = 0.0 , omega = 0.1 )","title":"ROBOT.MOVE"},{"location":"robot/robot/#robotstop","text":"robot.stop() Detiene el robot m\u00f3vil, estableciendo todas las velocidades a cero. Ejemplo de uso de metodo stop Este comando detiene completamente el movimiento del robot. robot . stop ()","title":"ROBOT.STOP"},{"location":"robot/robot/#robotset_custom_jacobian","text":"robot.set_custom_jacobian(func) Define una funci\u00f3n externa para calcular el jacobiano personalizado. Par\u00e1metros: func ( callable ): Funci\u00f3n que retorna una matriz jacobiana (lista de listas) Ejemplo de uso de metodo set_custom_jacobian Este comando permite definir un jacobiano personalizado para el robot, \u00fatil en aplicaciones espec\u00edficas. def my_jacobian (): return [[ 1 , 0 , - 1 ], [ 1 , 0 , 1 ], [ 1 , 0 , 1 ], [ 1 , 0 , - 1 ]] robot . set_custom_jacobian ( my_jacobian )","title":"ROBOT.SET_CUSTOM_JACOBIAN"},{"location":"robot/robot/#funciones-relacionadas-con-el-control-en-lazo-cerrado","text":"","title":"Funciones relacionadas con el control en lazo cerrado"},{"location":"robot/robot/#robotset_control_mode","text":"robot.set_control_mode(closed_loop=False) Activa o desactiva el control en lazo cerrado (PID) en todos los motores. Par\u00e1metros: closed_loop ( bool ): True para habilitar PID, False para desactivar Ejemplo de uso de metodo set_control_mode Este comando activa el control PID en todos los motores del robot. robot . set_control_mode ( closed_loop = True )","title":"ROBOT.SET_CONTROL_MODE"},{"location":"robot/robot/#robotset_pid_constants","text":"robot.set_pid_constants(motor_index, kp, ki=None, kd=None) Configura los par\u00e1metros PID de un motor en espec\u00edfico. Par\u00e1metros: motor_index ( int ): \u00cdndice del motor en la lista robot.motors kp ( float ): Constante proporcional ki ( float ): Constante integral (opcional) kd ( float ): Constante derivativa (opcional) Ejemplo de uso de metodo set_pid_constants Este comando ajusta los par\u00e1metros PID del primer motor del robot. robot . set_pid_constants ( motor_index = 0 , kp = 1.2 , ki = 0.5 , kd = 0.05 )","title":"ROBOT.SET_PID_CONSTANTS"},{"location":"robot/robot/#robotenable_auto_update","text":"robot.enable_auto_update(interval=10) Habilita la actualizaci\u00f3n peri\u00f3dica de los motores usando un Timer . Par\u00e1metros: interval ( int ): Periodo de actualizaci\u00f3n en milisegundos (por defecto 10 ms) Ejemplo de uso de metodo enable_auto_update Este comando activa la actualizaci\u00f3n autom\u00e1tica de los motores cada 20 ms. robot . enable_auto_update ( interval = 20 )","title":"ROBOT.ENABLE_AUTO_UPDATE"},{"location":"robot/robot/#funciones-relacionadas-con-los-motores-individuales","text":"","title":"Funciones relacionadas con los motores individuales"},{"location":"robot/robot/#robotmotorsidset_speed","text":"robot.motors[id].set_speed(speed_rps) Establece la velocidad objetivo del motor en revoluciones por segundo (rps). Ejemplo de uso de metodo set_speed Este comando establece la velocidad del primer motor a 10.0 rps. robot . motors [ 0 ] . set_speed ( 10.0 )","title":"ROBOT.MOTORS.ID.SET_SPEED"},{"location":"robot/robot/#robotmotorsidstop","text":"robot.motors[id].stop() Detiene el motor individual. Ejemplo de uso de metodo stop Este comando detiene el segundo motor del robot. robot . motors [ 1 ] . stop ()","title":"ROBOT.MOTORS.ID.STOP"},{"location":"robot/robot/#robotmotorsidget_speed","text":"robot.motors[id].get_speed() Retorna la velocidad actual del motor. Ejemplo de uso de metodo get_speed Este comando obtiene la velocidad actual del tercer motor. vel = robot . motors [ 2 ] . get_speed ()","title":"ROBOT.MOTORS.ID.GET_SPEED"},{"location":"robot/robot/#robotmotorsidget_state","text":"robot.motors[id].get_state() Retorna un diccionario con informaci\u00f3n del estado del motor (velocidad, posici\u00f3n, PID, etc). Ejemplo de uso de metodo get_state Este comando imprime el estado del cuarto motor, incluyendo velocidad y posici\u00f3n. print ( robot . motors [ 3 ] . get_state ())","title":"ROBOT.MOTORS.ID.GET_STATE"},{"location":"robot/robot/#robotmotorsidenable_close_loop_control","text":"robot.motors[id].enable_close_loop_control(True) Activa el control PID para ese motor. Ejemplo de uso de metodo enable_close_loop_control Este comando activa el control PID en el primer motor del robot. robot . motors [ 0 ] . enable_close_loop_control ( True )","title":"ROBOT.MOTORS.ID.ENABLE_CLOSE_LOOP_CONTROL"},{"location":"robot/robot/#robotmotorsidtune_pid","text":"robot.motors[id].tune_pid(kp, ki, kd) Ajusta los par\u00e1metros PID para un motor espec\u00edfico. Ejemplo de uso de metodo tune_pid Este comando ajusta los par\u00e1metros PID del primer motor a kp=1.0, ki=0.1, kd=0.01. robot . motors [ 0 ] . tune_pid ( kp = 1.0 , ki = 0.1 , kd = 0.01 )","title":"ROBOT.MOTORS.ID.TUNE_PID"},{"location":"robot/robot/#funciones-relacionadas-con-la-lectura-de-sensores-del-robot","text":"","title":"Funciones relacionadas con la lectura de sensores del robot"},{"location":"robot/robot/#robotsensorsread_imu_theta","text":"robot.sensors.read_imu_theta() Devuelve el \u00e1ngulo de orientaci\u00f3n estimado por el IMU (en radianes). Ejemplo de uso de metodo read_imu_theta Este comando obtiene el \u00e1ngulo de orientaci\u00f3n del robot desde el IMU. theta = robot . sensors . read_imu_theta ()","title":"ROBOT.SENSORS.READ_IMU_THETA"},{"location":"robot/robot/#robotsensorsread_imu_values","text":"robot.sensors.read_imu_values() Retorna los valores del IMU (aceler\u00f3metro y gir\u00f3scopo). Ejemplo de uso de metodo read_imu_values Este comando obtiene los valores del IMU, incluyendo aceleraci\u00f3n y velocidad angular. imu_data = robot . sensors . read_imu_values ()","title":"ROBOT.SENSORS.READ_IMU_VALUES"},{"location":"robot/robot/#robotsensorsread_ultrasonic_value","text":"robot.sensors.read_ultrasonic_value(sensor_id) Retorna la distancia medida por un sensor ultras\u00f3nico espec\u00edfico. Ejemplo de uso de metodo read_ultrasonic_value Este comando obtiene la distancia medida por el primer sensor ultras\u00f3nico. distancia = robot . sensors . read_ultrasonic_value ( sensor_id = 0 )","title":"ROBOT.SENSORS.READ_ULTRASONIC_VALUE"},{"location":"robot/robot/#robotsensorsread_ultrasonic_all","text":"robot.sensors.read_ultrasonic_all() Retorna una lista con las mediciones de todos los sensores ultras\u00f3nicos. Ejemplo de uso de metodo read_ultrasonic_all Este comando obtiene las distancias medidas por todos los sensores ultras\u00f3nicos del robot. distancias = robot . sensors . read_ultrasonic_all ()","title":"ROBOT.SENSORS.READ_ULTRASONIC_ALL"},{"location":"robot/robot/#robotupdate_odometry","text":"robot.update_odometry() Actualiza la posici\u00f3n estimada del robot. Actualmente no implementado, pero reservado para fusi\u00f3n de datos de encoders e IMU. Ejemplo de uso de metodo update_odometry Este comando actualiza la odometr\u00eda del robot, aunque actualmente no realiza ninguna acci\u00f3n. robot . update_odometry ()","title":"ROBOT.UPDATE_ODOMETRY"},{"location":"robot/robot/#robotmotors","text":"robot.motors Lista de objetos MotorWithPID que representan cada una de las ruedas del robot. Ejemplo de uso de la lista robot.motors Este comando itera sobre cada motor del robot e imprime su estado actual. for motor in robot . motors : print ( motor . get_state ())","title":"ROBOT.MOTORS"},{"location":"sensors/sensor/","text":"aqui sensores","title":"Sensor"},{"location":"sensors/sensor/#aqui-sensores","text":"","title":"aqui sensores"},{"location":"sensors/ultrasonico/","text":"aqui va la doc de ultrasonico","title":"Ultrasonico"},{"location":"sensors/ultrasonico/#aqui-va-la-doc-de-ultrasonico","text":"","title":"aqui va la doc de ultrasonico"},{"location":"test/test/","text":"aqu\u00ed test","title":"Test"},{"location":"test/test/#aqui-test","text":"","title":"aqu\u00ed test"},{"location":"utils/util/","text":"Aqui c\u00f3digo de utilidades","title":"Util"},{"location":"utils/util/#aqui-codigo-de-utilidades","text":"","title":"Aqui c\u00f3digo de utilidades"}]}