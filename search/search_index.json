{"config":{"indexing":"full","lang":["es"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Firmware educativo para Kits Rob\u00f3ticos \u2013 PUCP Este repositorio contiene el firmware base desarrollado en MicroPython para kits rob\u00f3ticos educativos utilizados en la carrera de Ingenier\u00eda Mecatr\u00f3nica en la Pontificia Universidad cat\u00f3lica del Per\u00fa . El proyecto est\u00e1 dise\u00f1ado para facilitar el aprendizaje pr\u00e1ctico de temas fundamentales en rob\u00f3tica m\u00f3vil y rob\u00f3tica de manipuladores. Objetivos del proyecto Desarrollar una plataforma de firmware modular y educativa que permita a los estudiantes: Objetivos Comprender y experimentar con cinem\u00e1tica de robots m\u00f3viles (diferencial, ackermann, mecanum). Programar y controlar brazos rob\u00f3ticos. Implementar algoritmos como \"Go to Goal\", planificaci\u00f3n de trayectorias y filtros de Kalman. Utilizar sensores reales (IMU, encoders, sensores ultras\u00f3nicos). Familiarizarse con conceptos de navegaci\u00f3n, control y percepci\u00f3n. Plataformas soportadas Robot con ruedas mecanum Brazos rob\u00f3ticos (Futuro) Vehiculo diferencial, ackerman, Robots con patas, LIDAR, otros sensores Estructura del repositorio Software_Pico/ \u2502 \u251c\u2500\u2500 firmware/ \u2190 C\u00f3digo fuente principal del firmware \u2502 \u251c\u2500\u2500 config/ \u2190 Archivos de configuraci\u00f3n (hardware, estudiantes) \u2502 \u251c\u2500\u2500 robot/ \u2190 Implementaciones de los distintos robots \u2502 \u251c\u2500\u2500 sensors/ \u2190 Interfaces para sensores (IMU, encoder, ultras\u00f3nicos) \u2502 \u251c\u2500\u2500 utils/ \u2190 Utilidades compartidas (PID, secuencias, jacobianos) \u2502 \u2514\u2500\u2500 libraries/ \u2190 Librer\u00edas externas o wrappers (MQTT, IMU) \u2502 \u251c\u2500\u2500 student_examples/ \u2190 Ejemplos de c\u00f3digo para uso en laboratorios \u251c\u2500\u2500 labs/ \u2190 Pr\u00e1cticas guiadas por tema o curso \u251c\u2500\u2500 tests/ \u2190 Scripts internos para pruebas de hardware/software \u2502 \u2514\u2500\u2500 helpers/ \u2190 Utilidades para pruebas \u251c\u2500\u2500 docs/ \u2190 Documentaci\u00f3n t\u00e9cnica y gu\u00edas de uso \u2502 \u2514\u2500\u2500 hardware \u2190 Diagramas de conexiones y specificaciones \u2502 \u2514\u2500\u2500 modules \u2190 Documentacion de modulos para uso de estudiantes \u2514\u2500\u2500 dev_tools/ \u2190 Scripts para compilaci\u00f3n, flasheo, etc. Inicio r\u00e1pido: C\u00f3mo usar el firmware 1. Flashear el raspberry pi pico W Sigue las instrucciones del archivo gu\u00eda de instalaci\u00f3n para instalar MicroPython y cargar los archivos necesarios. 2. Configurar tu robot Modifica \u00fanicamente el archivo firmware/config/student_config.py para definir par\u00e1metros ajustables por el usuario. MOTOR_DIRECTION = [ { \"encoder_inverted\" : True }, # Motor 0 { \"inverted\" : True }, # Motor 1 ] Advertencia Importante No modifiques config.mpy \u2014 este archivos est\u00e1 protegido para evitar da\u00f1os al hardware. 3. Ejecutar un script de ejemplo Desde Thonny, puedes ejecutar, por ejemplo: # Funci\u00f3n de diagn\u00f3stico para verificar sentido de giro y lectura del encoder from tests.helpers.motor import test_wheel_direction # Diccionario de configuraci\u00f3n que contiene par\u00e1metros del robot from config import CONFIG # Funci\u00f3n que retorna una instancia del robot basado en el tipo from robot import get_robot #========================================================= # Selecci\u00f3n del tipo de robot a utilizar en el test. # Debe de estar definido el config.py #========================================================= ROBOT_TYPE = 'test' # Inicializa la instancia del robot con los par\u00e1metros correspondientes robot = get_robot ( ROBOT_TYPE , CONFIG [ ROBOT_TYPE ]) # Ejecuta la prueba en el motor con \u00edndice 1 # Realizar la prueba con cada motor y modificar la configuraci\u00f3n # en config.py seg\u00fan corresponda test_wheel_direction ( robot , motor_id = 1 ) Laboratorios incluidos Carpeta Tema labs/pid_speed Control PID de velocidad labs/go_to_goal Movimiento hacia un objetivo (Go-to-Goal) labs/trajectory Planificaci\u00f3n de trayectorias labs/kalman Estimaci\u00f3n de estado con Filtro de Kalman labs/manipulators Cinem\u00e1tica de manipuladores Versionado Cada semestre acad\u00e9mico se etiqueta una versi\u00f3n estable del repositorio. Ejemplos de etiquetas ( tags ) Las versiones estables siguen el formato v<a\u00f1o>-<semestre>-labkit . v2025-1-labkit \u2192 Semestre 2025-1 v2024-2-labkit \u2192 Semestre 2024-2 Para ver y utilizar una versi\u00f3n anterior, puedes usar los siguientes comandos: git tag git checkout v2024-2-labkit Listar versiones: El comando git tag te mostrar\u00e1 todas las etiquetas disponibles en el historial del proyecto. Cambiar de versi\u00f3n: Una vez que identifiques la etiqueta que necesitas, git checkout te permite \"viajar en el tiempo\" a ese punto exacto del c\u00f3digo. Organizaci\u00f3n del Desarrollo Las contribuciones del equipo se organizan a trav\u00e9s de las siguientes ramas principales: Flujo de Ramas en Git main \u2014 Versi\u00f3n estable. dev \u2014 Desarrollo activo. feature/<nombre> \u2014 Funcionalidades nuevas en desarrollo. course/<curso> \u2014 Adaptaciones espec\u00edficas para cursos o pr\u00e1cticas Licencia Este proyecto es de uso acad\u00e9mico exclusivo para cursos dictados en la PUCP. Para solicitudes de uso externo, contactar con el equipo docente o coordinador del proyecto. Contacto Para dudas, soporte o sugerencias: Coordinador t\u00e9cnico: [dequiroz@pucp.edu.pe] Repositorio oficial: https://github.com/PUCP-Robotica-IA/Software_Pico","title":"Introducci\u00f3n"},{"location":"#firmware-educativo-para-kits-roboticos-pucp","text":"Este repositorio contiene el firmware base desarrollado en MicroPython para kits rob\u00f3ticos educativos utilizados en la carrera de Ingenier\u00eda Mecatr\u00f3nica en la Pontificia Universidad cat\u00f3lica del Per\u00fa . El proyecto est\u00e1 dise\u00f1ado para facilitar el aprendizaje pr\u00e1ctico de temas fundamentales en rob\u00f3tica m\u00f3vil y rob\u00f3tica de manipuladores.","title":"Firmware educativo para Kits Rob\u00f3ticos \u2013 PUCP"},{"location":"#objetivos-del-proyecto","text":"Desarrollar una plataforma de firmware modular y educativa que permita a los estudiantes: Objetivos Comprender y experimentar con cinem\u00e1tica de robots m\u00f3viles (diferencial, ackermann, mecanum). Programar y controlar brazos rob\u00f3ticos. Implementar algoritmos como \"Go to Goal\", planificaci\u00f3n de trayectorias y filtros de Kalman. Utilizar sensores reales (IMU, encoders, sensores ultras\u00f3nicos). Familiarizarse con conceptos de navegaci\u00f3n, control y percepci\u00f3n.","title":"Objetivos del proyecto"},{"location":"#plataformas-soportadas","text":"Robot con ruedas mecanum Brazos rob\u00f3ticos (Futuro) Vehiculo diferencial, ackerman, Robots con patas, LIDAR, otros sensores","title":"Plataformas soportadas"},{"location":"#estructura-del-repositorio","text":"Software_Pico/ \u2502 \u251c\u2500\u2500 firmware/ \u2190 C\u00f3digo fuente principal del firmware \u2502 \u251c\u2500\u2500 config/ \u2190 Archivos de configuraci\u00f3n (hardware, estudiantes) \u2502 \u251c\u2500\u2500 robot/ \u2190 Implementaciones de los distintos robots \u2502 \u251c\u2500\u2500 sensors/ \u2190 Interfaces para sensores (IMU, encoder, ultras\u00f3nicos) \u2502 \u251c\u2500\u2500 utils/ \u2190 Utilidades compartidas (PID, secuencias, jacobianos) \u2502 \u2514\u2500\u2500 libraries/ \u2190 Librer\u00edas externas o wrappers (MQTT, IMU) \u2502 \u251c\u2500\u2500 student_examples/ \u2190 Ejemplos de c\u00f3digo para uso en laboratorios \u251c\u2500\u2500 labs/ \u2190 Pr\u00e1cticas guiadas por tema o curso \u251c\u2500\u2500 tests/ \u2190 Scripts internos para pruebas de hardware/software \u2502 \u2514\u2500\u2500 helpers/ \u2190 Utilidades para pruebas \u251c\u2500\u2500 docs/ \u2190 Documentaci\u00f3n t\u00e9cnica y gu\u00edas de uso \u2502 \u2514\u2500\u2500 hardware \u2190 Diagramas de conexiones y specificaciones \u2502 \u2514\u2500\u2500 modules \u2190 Documentacion de modulos para uso de estudiantes \u2514\u2500\u2500 dev_tools/ \u2190 Scripts para compilaci\u00f3n, flasheo, etc.","title":"Estructura del repositorio"},{"location":"#inicio-rapido-como-usar-el-firmware","text":"","title":"Inicio r\u00e1pido: C\u00f3mo usar el firmware"},{"location":"#1-flashear-el-raspberry-pi-pico-w","text":"Sigue las instrucciones del archivo gu\u00eda de instalaci\u00f3n para instalar MicroPython y cargar los archivos necesarios.","title":"1. Flashear el raspberry pi pico W"},{"location":"#2-configurar-tu-robot","text":"Modifica \u00fanicamente el archivo firmware/config/student_config.py para definir par\u00e1metros ajustables por el usuario. MOTOR_DIRECTION = [ { \"encoder_inverted\" : True }, # Motor 0 { \"inverted\" : True }, # Motor 1 ] Advertencia Importante No modifiques config.mpy \u2014 este archivos est\u00e1 protegido para evitar da\u00f1os al hardware.","title":"2. Configurar tu robot"},{"location":"#3-ejecutar-un-script-de-ejemplo","text":"Desde Thonny, puedes ejecutar, por ejemplo: # Funci\u00f3n de diagn\u00f3stico para verificar sentido de giro y lectura del encoder from tests.helpers.motor import test_wheel_direction # Diccionario de configuraci\u00f3n que contiene par\u00e1metros del robot from config import CONFIG # Funci\u00f3n que retorna una instancia del robot basado en el tipo from robot import get_robot #========================================================= # Selecci\u00f3n del tipo de robot a utilizar en el test. # Debe de estar definido el config.py #========================================================= ROBOT_TYPE = 'test' # Inicializa la instancia del robot con los par\u00e1metros correspondientes robot = get_robot ( ROBOT_TYPE , CONFIG [ ROBOT_TYPE ]) # Ejecuta la prueba en el motor con \u00edndice 1 # Realizar la prueba con cada motor y modificar la configuraci\u00f3n # en config.py seg\u00fan corresponda test_wheel_direction ( robot , motor_id = 1 )","title":"3. Ejecutar un script de ejemplo"},{"location":"#laboratorios-incluidos","text":"Carpeta Tema labs/pid_speed Control PID de velocidad labs/go_to_goal Movimiento hacia un objetivo (Go-to-Goal) labs/trajectory Planificaci\u00f3n de trayectorias labs/kalman Estimaci\u00f3n de estado con Filtro de Kalman labs/manipulators Cinem\u00e1tica de manipuladores","title":"Laboratorios incluidos"},{"location":"#versionado","text":"Cada semestre acad\u00e9mico se etiqueta una versi\u00f3n estable del repositorio. Ejemplos de etiquetas ( tags ) Las versiones estables siguen el formato v<a\u00f1o>-<semestre>-labkit . v2025-1-labkit \u2192 Semestre 2025-1 v2024-2-labkit \u2192 Semestre 2024-2 Para ver y utilizar una versi\u00f3n anterior, puedes usar los siguientes comandos: git tag git checkout v2024-2-labkit Listar versiones: El comando git tag te mostrar\u00e1 todas las etiquetas disponibles en el historial del proyecto. Cambiar de versi\u00f3n: Una vez que identifiques la etiqueta que necesitas, git checkout te permite \"viajar en el tiempo\" a ese punto exacto del c\u00f3digo.","title":"Versionado"},{"location":"#organizacion-del-desarrollo","text":"Las contribuciones del equipo se organizan a trav\u00e9s de las siguientes ramas principales: Flujo de Ramas en Git main \u2014 Versi\u00f3n estable. dev \u2014 Desarrollo activo. feature/<nombre> \u2014 Funcionalidades nuevas en desarrollo. course/<curso> \u2014 Adaptaciones espec\u00edficas para cursos o pr\u00e1cticas","title":"Organizaci\u00f3n del Desarrollo"},{"location":"#licencia","text":"Este proyecto es de uso acad\u00e9mico exclusivo para cursos dictados en la PUCP. Para solicitudes de uso externo, contactar con el equipo docente o coordinador del proyecto.","title":"Licencia"},{"location":"#contacto","text":"Para dudas, soporte o sugerencias: Coordinador t\u00e9cnico: [dequiroz@pucp.edu.pe] Repositorio oficial: https://github.com/PUCP-Robotica-IA/Software_Pico","title":"Contacto"},{"location":"configure/configure/","text":"CONFIGURACIONES INICIALES config.py \ud83d\udce6 CONFIG: Diccionario de configuraci\u00f3n de hardware Este bloque de c\u00f3digo es un diccionario en Python que contiene la configuraci\u00f3n de hardware para distintos tipos de robots o dispositivos. Cada clave representa una configuraci\u00f3n espec\u00edfica que puede activarse seg\u00fan el tipo de robot que se est\u00e9 utilizando. CONFIG [\"test\"] : Configura al robot omnidireccional en modo prueba para usar dos de sus ruedas mediante mediante se\u00f1ales PWM, encoders(a,b) y direcci\u00f3n. PWM, direcci\u00f3n y encoders. CONFIG [\"mecanum\"] : Configura al robot omnidireccional para usar sus cuatro ruedas y sensores asociador. PWM, direcci\u00f3n y encoders. Sensores ultras\u00f3nicos (3) conectados a pines anal\u00f3gicos (ADC). Sensor IMU conectado por I2C. CONFIG [\"arm\"] : Configura al brazo robotico de cuatro grados de libertad. 4 servomotores. Salida para efector final. Sensor ultrasonido. CONFIG [\"sensors\"] : Configura al brazo robotico de cuatro grados de libertad. Sensores ultras\u00f3nicos (3) conectados a pines anal\u00f3gicos (ADC). Sensor IMU conectado por I2C. merge_motor_directions(config) Esta funci\u00f3n toma un subdiccionario del diccionario CONFIG que contiene una lista de par\u00e1metros de configuraci\u00f3n para motores bajo la clave \"motors\", y fusiona cada uno de ellos con posibles valores adicionales definidos externamente (por ejemplo, direcciones personalizadas). Par\u00e1metros: config: 'dict' Diccionario de configuraci\u00f3n de hardware correspondiente al robot omnidireccional.","title":"Configuraci\u00f3n de pines"},{"location":"configure/configure/#configuraciones-iniciales","text":"","title":"CONFIGURACIONES INICIALES"},{"location":"configure/configure/#configpy","text":"\ud83d\udce6 CONFIG: Diccionario de configuraci\u00f3n de hardware Este bloque de c\u00f3digo es un diccionario en Python que contiene la configuraci\u00f3n de hardware para distintos tipos de robots o dispositivos. Cada clave representa una configuraci\u00f3n espec\u00edfica que puede activarse seg\u00fan el tipo de robot que se est\u00e9 utilizando. CONFIG [\"test\"] : Configura al robot omnidireccional en modo prueba para usar dos de sus ruedas mediante mediante se\u00f1ales PWM, encoders(a,b) y direcci\u00f3n. PWM, direcci\u00f3n y encoders. CONFIG [\"mecanum\"] : Configura al robot omnidireccional para usar sus cuatro ruedas y sensores asociador. PWM, direcci\u00f3n y encoders. Sensores ultras\u00f3nicos (3) conectados a pines anal\u00f3gicos (ADC). Sensor IMU conectado por I2C. CONFIG [\"arm\"] : Configura al brazo robotico de cuatro grados de libertad. 4 servomotores. Salida para efector final. Sensor ultrasonido. CONFIG [\"sensors\"] : Configura al brazo robotico de cuatro grados de libertad. Sensores ultras\u00f3nicos (3) conectados a pines anal\u00f3gicos (ADC). Sensor IMU conectado por I2C. merge_motor_directions(config) Esta funci\u00f3n toma un subdiccionario del diccionario CONFIG que contiene una lista de par\u00e1metros de configuraci\u00f3n para motores bajo la clave \"motors\", y fusiona cada uno de ellos con posibles valores adicionales definidos externamente (por ejemplo, direcciones personalizadas). Par\u00e1metros: config: 'dict' Diccionario de configuraci\u00f3n de hardware correspondiente al robot omnidireccional.","title":"config.py"},{"location":"guides/micropython_guide/","text":"Gu\u00eda de instalaci\u00f3n del firmware Sigue estos tres pasos para preparar tu placa Raspberry Pi Pico W para el laboratorio. Requisitos Una placa Raspberry Pi Pico W . Un cable de datos micro-USB. El editor Thonny IDE instalado. Paso 1: Descargar el firmware Primero, obt\u00e9n el archivo de firmware oficial de MicroPython, descargar la \u00faltima versi\u00f3n del firmware. Firmware MicroPython para Pico W (.uf2) Guarda este archivo en tu escritorio o en un lugar f\u00e1cil de encontrar. Paso 2: Instalar el firmware en la placa Ahora, vamos a \"flashear\" el firmware en la memoria del Pico. Mant\u00e9n presionado el bot\u00f3n BOOTSEL de tu Pico. Imagen: Bot\u00f3n BOOTSEL Sin soltarlo , conecta el Pico a tu computadora. Aparecer\u00e1 una unidad llamada RPI-RP2 . Ahora suelta el bot\u00f3n BOOTSEL . Imagen: Unidad RPI-RP2 ! 4. Arrastra y suelta el archivo .uf2 que descargaste sobre esa unidad RPI-RP2 . \u00a1Firmware Instalado! La placa se reiniciar\u00e1 sola y la unidad RPI-RP2 desaparecer\u00e1 de tu explorador de archivos. Esto es normal y significa que la instalaci\u00f3n fue exitosa. \u00a1Listo! Tu placa ya tiene MicroPython instalado. Ahora est\u00e1s listo para continuar con la siguiente gu\u00eda: programarla usando Thonny .","title":"Micropython"},{"location":"guides/micropython_guide/#guia-de-instalacion-del-firmware","text":"Sigue estos tres pasos para preparar tu placa Raspberry Pi Pico W para el laboratorio. Requisitos Una placa Raspberry Pi Pico W . Un cable de datos micro-USB. El editor Thonny IDE instalado.","title":"Gu\u00eda de instalaci\u00f3n del firmware"},{"location":"guides/micropython_guide/#paso-1-descargar-el-firmware","text":"Primero, obt\u00e9n el archivo de firmware oficial de MicroPython, descargar la \u00faltima versi\u00f3n del firmware. Firmware MicroPython para Pico W (.uf2) Guarda este archivo en tu escritorio o en un lugar f\u00e1cil de encontrar.","title":"Paso 1: Descargar el firmware"},{"location":"guides/micropython_guide/#paso-2-instalar-el-firmware-en-la-placa","text":"Ahora, vamos a \"flashear\" el firmware en la memoria del Pico. Mant\u00e9n presionado el bot\u00f3n BOOTSEL de tu Pico. Imagen: Bot\u00f3n BOOTSEL Sin soltarlo , conecta el Pico a tu computadora. Aparecer\u00e1 una unidad llamada RPI-RP2 . Ahora suelta el bot\u00f3n BOOTSEL . Imagen: Unidad RPI-RP2 ! 4. Arrastra y suelta el archivo .uf2 que descargaste sobre esa unidad RPI-RP2 . \u00a1Firmware Instalado! La placa se reiniciar\u00e1 sola y la unidad RPI-RP2 desaparecer\u00e1 de tu explorador de archivos. Esto es normal y significa que la instalaci\u00f3n fue exitosa.","title":"Paso 2: Instalar el firmware en la placa"},{"location":"guides/micropython_guide/#listo","text":"Tu placa ya tiene MicroPython instalado. Ahora est\u00e1s listo para continuar con la siguiente gu\u00eda: programarla usando Thonny .","title":"\u00a1Listo!"},{"location":"guides/thony_guide/","text":"Gu\u00eda 2: Tu primer programa con Thonny Ahora que tu placa tiene el firmware, vamos a comprobar que todo funciona correctamente. Para ello, instalaremos el editor Thonny y ejecutaremos un c\u00f3digo que haga parpadear el LED de la placa. Requisitos Haber completado la Gu\u00eda 1: Instalaci\u00f3n del Firmware . Tu placa Raspberry Pi Pico W (ya con el firmware). Un cable de datos micro-USB. Paso 1: Instalar el editor Thonny Thonny es el Entorno de Desarrollo Integrado (IDE) que usaremos. Es perfecto para principiantes porque es sencillo e incluye todo lo necesario para programar la Pico. Descarga Thonny desde su p\u00e1gina oficial: https://thonny.org/ Instala el programa en tu computadora siguiendo los pasos del asistente. Paso 2: Conectar la placa a Thonny Abre Thonny . Conecta tu Raspberry Pi Pico W a la computadora (esta vez de forma normal, sin presionar BOOTSEL ). En la esquina inferior derecha de Thonny, haz clic y aseg\u00farate de que est\u00e9 seleccionado el int\u00e9rprete MicroPython (Raspberry Pi Pico) . Si no aparece, desconecta y vuelve a conectar la placa. Imagen: Selecci\u00f3n del int\u00e9rprete MicroPython (Raspberry Pi Pico) en Thonny. Paso 3: C\u00f3digo de prueba (LED intermitente) Vamos a escribir y ejecutar nuestro primer programa para verificar la conexi\u00f3n. Copia el siguiente c\u00f3digo y p\u00e9galo en la ventana principal del editor de Thonny (donde dice <untitled> ). # Importamos las herramientas necesarias from machine import Pin from time import sleep # Configuramos el pin del LED integrado como una salida. # En la Pico W, el LED se llama 'LED'. led = Pin ( 'LED' , Pin . OUT ) # Creamos un bucle infinito para que el programa se repita sin parar while True : led . on () # Encender el LED sleep ( 1 ) # Esperar 1 segundo led . off () # Apagar el LED sleep ( 1 ) # Esperar 1 segundo Haz clic en el bot\u00f3n verde de \"Play\" (\u25b6) o presiona la tecla F5 para ejecutar el c\u00f3digo. Imagen: LED intermitente \u00a1Verificaci\u00f3n Exitosa! Si todo sali\u00f3 bien, el LED verde integrado en tu Pico W comenzar\u00e1 a parpadear (se enciende por un segundo y se apaga por un segundo). \u00a1Felicidades, has ejecutado tu primer programa! Para detenerlo, haz clic en el bot\u00f3n rojo de \"Stop\" (\u25a0) en Thonny. Paso 4 (Opcional pero recomendado): Guardar el c\u00f3digo en la placa Para que tu programa se ejecute autom\u00e1ticamente cada vez que conectes la placa (sin necesidad de una computadora), gu\u00e1rdalo con el nombre main.py . Ve a Archivo > Guardar como... ( File > Save as... ). Elige guardar en Raspberry Pi Pico . Nombra el archivo exactamente como main.py y haz clic en OK . Imagen: Guardar c\u00f3digo main.py en la raspberry pi pico W El poder de main.py Cualquier c\u00f3digo guardado como main.py en la memoria de la Pico se ejecutar\u00e1 autom\u00e1ticamente al encenderla.","title":"Thony"},{"location":"guides/thony_guide/#guia-2-tu-primer-programa-con-thonny","text":"Ahora que tu placa tiene el firmware, vamos a comprobar que todo funciona correctamente. Para ello, instalaremos el editor Thonny y ejecutaremos un c\u00f3digo que haga parpadear el LED de la placa. Requisitos Haber completado la Gu\u00eda 1: Instalaci\u00f3n del Firmware . Tu placa Raspberry Pi Pico W (ya con el firmware). Un cable de datos micro-USB.","title":"Gu\u00eda 2: Tu primer programa con Thonny"},{"location":"guides/thony_guide/#paso-1-instalar-el-editor-thonny","text":"Thonny es el Entorno de Desarrollo Integrado (IDE) que usaremos. Es perfecto para principiantes porque es sencillo e incluye todo lo necesario para programar la Pico. Descarga Thonny desde su p\u00e1gina oficial: https://thonny.org/ Instala el programa en tu computadora siguiendo los pasos del asistente.","title":"Paso 1: Instalar el editor Thonny"},{"location":"guides/thony_guide/#paso-2-conectar-la-placa-a-thonny","text":"Abre Thonny . Conecta tu Raspberry Pi Pico W a la computadora (esta vez de forma normal, sin presionar BOOTSEL ). En la esquina inferior derecha de Thonny, haz clic y aseg\u00farate de que est\u00e9 seleccionado el int\u00e9rprete MicroPython (Raspberry Pi Pico) . Si no aparece, desconecta y vuelve a conectar la placa. Imagen: Selecci\u00f3n del int\u00e9rprete MicroPython (Raspberry Pi Pico) en Thonny.","title":"Paso 2: Conectar la placa a Thonny"},{"location":"guides/thony_guide/#paso-3-codigo-de-prueba-led-intermitente","text":"Vamos a escribir y ejecutar nuestro primer programa para verificar la conexi\u00f3n. Copia el siguiente c\u00f3digo y p\u00e9galo en la ventana principal del editor de Thonny (donde dice <untitled> ). # Importamos las herramientas necesarias from machine import Pin from time import sleep # Configuramos el pin del LED integrado como una salida. # En la Pico W, el LED se llama 'LED'. led = Pin ( 'LED' , Pin . OUT ) # Creamos un bucle infinito para que el programa se repita sin parar while True : led . on () # Encender el LED sleep ( 1 ) # Esperar 1 segundo led . off () # Apagar el LED sleep ( 1 ) # Esperar 1 segundo Haz clic en el bot\u00f3n verde de \"Play\" (\u25b6) o presiona la tecla F5 para ejecutar el c\u00f3digo. Imagen: LED intermitente \u00a1Verificaci\u00f3n Exitosa! Si todo sali\u00f3 bien, el LED verde integrado en tu Pico W comenzar\u00e1 a parpadear (se enciende por un segundo y se apaga por un segundo). \u00a1Felicidades, has ejecutado tu primer programa! Para detenerlo, haz clic en el bot\u00f3n rojo de \"Stop\" (\u25a0) en Thonny.","title":"Paso 3: C\u00f3digo de prueba (LED intermitente)"},{"location":"guides/thony_guide/#paso-4-opcional-pero-recomendado-guardar-el-codigo-en-la-placa","text":"Para que tu programa se ejecute autom\u00e1ticamente cada vez que conectes la placa (sin necesidad de una computadora), gu\u00e1rdalo con el nombre main.py . Ve a Archivo > Guardar como... ( File > Save as... ). Elige guardar en Raspberry Pi Pico . Nombra el archivo exactamente como main.py y haz clic en OK . Imagen: Guardar c\u00f3digo main.py en la raspberry pi pico W El poder de main.py Cualquier c\u00f3digo guardado como main.py en la memoria de la Pico se ejecutar\u00e1 autom\u00e1ticamente al encenderla.","title":"Paso 4 (Opcional pero recomendado): Guardar el c\u00f3digo en la placa"},{"location":"robot/robot/","text":"Clase robot class MobileRobot(motor_config) Clase base para un robot m\u00f3vil con m\u00faltiples motores controlados por PID. Representa una plataforma gen\u00e9rica de robot m\u00f3vil que permite el control de m\u00faltiples motores, integraci\u00f3n de modelos cinem\u00e1ticos personalizados (jacobianos), actualizaci\u00f3n peri\u00f3dica mediante temporizador y ajuste de controladores PID por motor. Nota: Admite robots de tipo diferencial y mecanum u otras arquitecturas que compartan el mismo esquema de control individual por rueda. Parametros: motor_configs : dict Lista de diccionarios con los par\u00e1metros de configuraci\u00f3n de cada motor. Cada diccionario debe incluir al menos: Metodos: move(self, vx, vy, omega) stop() enable_auto_update(self, interval=10) _update_motors() set_custom_jacobian(func) _jacobian() default_jacobian() _compute_wheel_speeds(vx, vy, omega) update_odometry() set_control_mode() set_pid_constants(motor_index, kp) Ejemplos: from config import CONFIG from robot.base import MobileRobot robot = MobileRobot(config) robot.move(vx=0.2, vy=0.0, omega=0.1)","title":"Robot"},{"location":"robot/robot/#clase-robot","text":"class MobileRobot(motor_config) Clase base para un robot m\u00f3vil con m\u00faltiples motores controlados por PID. Representa una plataforma gen\u00e9rica de robot m\u00f3vil que permite el control de m\u00faltiples motores, integraci\u00f3n de modelos cinem\u00e1ticos personalizados (jacobianos), actualizaci\u00f3n peri\u00f3dica mediante temporizador y ajuste de controladores PID por motor. Nota: Admite robots de tipo diferencial y mecanum u otras arquitecturas que compartan el mismo esquema de control individual por rueda. Parametros: motor_configs : dict Lista de diccionarios con los par\u00e1metros de configuraci\u00f3n de cada motor. Cada diccionario debe incluir al menos: Metodos: move(self, vx, vy, omega) stop() enable_auto_update(self, interval=10) _update_motors() set_custom_jacobian(func) _jacobian() default_jacobian() _compute_wheel_speeds(vx, vy, omega) update_odometry() set_control_mode() set_pid_constants(motor_index, kp) Ejemplos: from config import CONFIG from robot.base import MobileRobot robot = MobileRobot(config) robot.move(vx=0.2, vy=0.0, omega=0.1)","title":"Clase robot"},{"location":"sensors/sensor/","text":"aqui sensores","title":"sensor"},{"location":"sensors/sensor/#aqui-sensores","text":"","title":"aqui sensores"},{"location":"sensors/ultrasonico/","text":"aqui va la doc de ultrasonico","title":"ultrasonido"},{"location":"sensors/ultrasonico/#aqui-va-la-doc-de-ultrasonico","text":"","title":"aqui va la doc de ultrasonico"},{"location":"test/test/","text":"aqu\u00ed test","title":"prueba1"},{"location":"test/test/#aqui-test","text":"","title":"aqu\u00ed test"},{"location":"utils/util/","text":"Aqui c\u00f3digo de utilidades","title":"utilidad"},{"location":"utils/util/#aqui-codigo-de-utilidades","text":"","title":"Aqui c\u00f3digo de utilidades"}]}